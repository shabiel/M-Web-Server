v 0.1.1 of MWS.RSA
GT.M 01-JAN-2014 14:00:50
%W0
%W0 ; VEN/SMH - Infrastructure web services hooks;2013-09-04  2:04 AM ; 12/18/13 3:25pm
 ;;1.0;MUMPS ADVANCED SHELL;;Sep 01, 2012;Build 6
 ;
R(RESULT,ARGS) ; GET Mumps Routine
 S RESULT("mime")="text/plain; charset=utf-8"
 S RESULT=$NA(^TMP($J))
 K @RESULT
 N RTN S RTN=$G(ARGS("routine"))
 N OFF,I
 I RTN]""&($T(^@RTN)]"") F I=1:1 S OFF="+"_I,LN0=OFF_"^"_RTN,LN=$T(@LN0) Q:LN=""  S @RESULT@(I)=LN_$C(13,10)
 E  K RESULT("mime") D SETERROR^VPRJRUT(404,"Routine not found")
 QUIT
 ;
PR(ARGS,BODY,RESULT) ; PUT Mumps Routine
 S HTTPRSP("mime")="text/plain; charset=utf-8" ; Character set of the return URL
 N PARSED ; Parsed array which stores each line on a separate node.
 D PARSE10^VPRJRUT(.BODY,.PARSED) ; Parser
 N DIE,XCN S DIE="PARSED(",XCN=0 D SAVE(ARGS("routine"))
 Q RESULT
 ;
SAVE(RN)        ;Save a routine
 Q:$E(RN,1,4)'="KBAN"  ; Just for this server, don't do this.
 N %,%F,%I,%N,SP,$ETRAP
 S $ETRAP="S $ECODE="""" Q"
 S %I=$I,SP=" ",%F=$$RTNDIR^%ZOSV()_$TR(RN,"%","_")_".m"
 O %F:(newversion:noreadonly:blocksize=2048:recordsize=2044) U %F
 F  S XCN=$O(@(DIE_XCN_")")) Q:XCN'>0  S %=@(DIE_XCN_")") Q:$E(%,1)="$"  I $E(%)'=";" W %,!
 C %F ;S %N=$$NULL
 ZLINK RN
 ;C %N
 U %I
 Q
FV(RESULTS,ARGS) ; Get fileman field value, handles fileman/file/iens/field
 I $$UNKARGS^VPRJRUT(.ARGS,"file,iens,field,screen,match") Q  ; Is any of these not passed?
 S RESULTS("mime")="text/plain; charset=utf-8" ; type of data to send browser
 N FILE S FILE=$G(ARGS("file")) ; se
 N IENS S IENS=$G(ARGS("iens")) ; se
 N FIELD S FIELD=$G(ARGS("field")) ; se
 I IENS?1A.AN D LISTER(.RESULTS,.ARGS) QUIT
 S RESULTS=$$GET1^DIQ(FILE,IENS,FIELD,,$NA(^TMP($J))) ; double trouble.
 I $D(^TMP("DIERR",$J)) D SETERROR^VPRJRUT(404,"File or field not found") QUIT
 ; if results is a regular field, that's the value we will get.
 ; if results is a WP field, RESULTS becomes the global ^TMP($J).
 I $D(^TMP($J)) D ADDCRLF^VPRJRUT(.RESULTS) ; crlf the result
 ;ZSHOW "D":^KBANDEV
 QUIT
 ;
LISTER(RESULTS,ARGS) ; FV divergence in case an index is requested.
 K RESULTS("mime")
 N FILE S FILE=$G(ARGS("file"))
 N INDEX S INDEX=$G(ARGS("iens"))
 N FROM S FROM=$G(ARGS("field"))
 ; I $L(FROM) D 
 ; . I +FROM'=FROM S FROM=$E(FROM,1,$L(FROM)-1)_"              " ; backtrack in index alpha style
 ; . E  S FROM=FROM-1   ; backtrack numeric style
 ;
 N SCREEN S SCREEN=$G(ARGS("screen"))
 I $L(SCREEN) D
 . N Q S Q=""""
 . N FLD,VAL
 . S FLD=$P(SCREEN,":")
 . S VAL=$P(SCREEN,":",2)
 . I VAL'=+VAL S VAL=Q_VAL_Q ; Quote literal values
 . N FLDNUM S FLDNUM=$O(^DD(FILE,"B",FLD,""))
 . Q:'FLDNUM
 . N GL S GL=$P(^DD(FILE,FLDNUM,0),U,4)
 . N GLN S GLN=$P(GL,";")
 . I GLN'=+GLN S GLN=Q_GLN_Q ; Quote literal nodes
 . N GLP S GLP=$P(GL,";",2)
 . I $E(GLP)="E" D
 . . N START S START=$P(GLP,","),START=$E(GLP,2,99)
 . . N END S END=$P(GLP,",",2)
 . . S SCREEN="I $E(^("_GLN_"),"_START_","_END_")="_VAL
 . E  D
 . . S SCREEN="I $P(^("_GLN_"),U,"_GLP_")="_VAL
 ;
 N FLAGS S FLAGS="QP" ; Default flag
 ; 
 ; TODO: if index is not compound, don't apply matching below; send X flag to finder instead.
 ; I $G(ARGS("match"))="exact" S FLAGS=FLAGS_"X"
 N %WRES,%WERR
 ; %WRES("DILIST",0)="200^200^1^"
 ; %WRES("DILIST",0,"MAP")="IEN^IX(1)^.01^FID(.12)^FID(.13)^FID(.14)"
 ; %WRES("DILIST",1,0)="8870^CA - CALCIUM^1895^SNOMEDCT^SY^5540006"
 ; %WRES("DILIST",2,0)="60527^CA - CHOLIC ACID^20969^SNOMEDCT^SY^17147002"
 ; %WRES("DILIST",3,0)="606334^CA 1000/MAGNESIUM 400/ZINC 15M^810433^VANDF^AB^40252
 I FROM="" D
 . D LIST^DIC(FILE,,"IX;FID",FLAGS,200,,,INDEX,SCREEN,"",$NA(%WRES),$NA(%WERR))
 E  D FIND^DIC(FILE,,"IX;FID",FLAGS,FROM,200,INDEX,SCREEN,"",$NA(%WRES),$NA(%WERR))
 ;
 ; 
 ; Filter only for exact matches if requested. 
 ; Get IX(1) entries and make sure they are the same as the original values.
 I $G(ARGS("match"))="exact" D
 . ; I looper to set IX(1) piece location
 . N I F I=1:1:$L(%WRES("DILIST",0,"MAP"),U) Q:$P(%WRES("DILIST",0,"MAP"),U,I)="IX(1)"
 . N IX1P S IX1P=I ; IX(1) piece location
 . N I S I=0 F  S I=$O(%WRES("DILIST",I)) Q:'I  D  ; Remove IX(1)'s that don't match
 . . I $P(%WRES("DILIST",I,0),U,IX1P)'=FROM K %WRES("DILIST",I,0)
 ;
 ;
 K ^KBANRPC ZSHOW "*":^KBANRPC
 ;
 ;
 I $D(DIERR) D SETERROR^VPRJRUT("500","Lister error") Q
 N MAP S MAP=%WRES("DILIST",0,"MAP")
 S MAP=$$REMAP(MAP,FILE)
 N %WRES2
 N I S I=0
 F  S I=$O(%WRES("DILIST",I)) Q:'I  D
 . N IEN
 . S NODE=%WRES("DILIST",I,0)
 . N P F P=1:1:$L(MAP,U) I $P(MAP,U,P)["IEN" S IEN=$P(NODE,U,P)
 . N P F P=1:1:$L(MAP,U) S %WRES2(IEN,$P(MAP,U,P))=$P(NODE,U,P)
 . K %WRES("DILIST",I,0)
 K %WRES("DILIST",0)
 N %WJSON,%WERR
 D ENCODE^VPRJSON($NA(%WRES2),$NA(%WJSON),$NA(%WERR))
 I $D(%WERR) D SETERROR^VPRJRUT("500","Error in JSON conversion") Q
 M RESULTS=%WJSON
 QUIT
 ;
REMAP(MAP,FILE) ; Private $$ - Remap the map from the lister
 N NEWMAP
 N I F I=1:1:$L(MAP,U) D
 . N P S P=$P(MAP,U,I)
 . I P["IX(" S P="INDEX VALUE "_+$P(P,"IX(",2)
 . I $E(P,1,3)=".01" S P="#"_P_" "_$$GET1^DID(FILE,.01,"","LABEL")
 . I P["FID(" N FLD S FLD=+$P(P,"FID(",2),P="#"_FLD_" "_$$GET1^DID(FILE,FLD,"","LABEL")
 . I P="IEN" S P="#.001 IEN"
 . S $P(NEWMAP,U,I)=P
 Q NEWMAP
 ;
LISTERT 
 N ARGS S ARGS("file")=176.001,ARGS("iens")="STR",ARGS("field")="CA"
 D LISTER(,.ARGS)
 N ARGS S ARGS("file")=176.005,ARGS("iens")="B",ARGS("field")="87795"
 D LISTER(,.ARGS)
 QUIT
 ;
F(RESULT,ARGS) ; handles fileman/{file}/{iens}
 I $$UNKARGS^VPRJRUT(.ARGS,"file,iens") Q  ; Is any of these not passed?
 N FILE S FILE=$G(ARGS("file")) ; se
 N IENS S IENS=$G(ARGS("iens")) ; se
 N %WRTN,%WERR
 N DIERR
 D GETS^DIQ(FILE,IENS,"*","RN",$NA(%WRTN),$NA(%WERR))
 I $D(DIERR) D SETERROR^VPRJRUT("500","Error in GETS^DIQ Selection") Q
 N %WERR
 D ENCODE^VPRJSON($NA(%WRTN(FILE,IENS_",")),$NA(RESULT),$NA(%WERR))
 ; debug
 ;K ^KBANRPC 
 ;ZSHOW "V":^KBANRPC
 ; debug
 I $D(%WERR) D SETERROR^VPRJRUT("500","Error in JSON conversion") Q
 QUIT
 ;
MOCHA(RESULTS,ARGS) ;
 K RESULTS
 S RESULTS("mime")="text/xml; charset=utf-8"
 N TYPE S TYPE=$G(ARGS("type"))
 I TYPE="" K RESULTS("mime") D SETERROR^VPRJRUT(404,"MOCHA web service not found")
 N XMLRTN D GETXML^KBAIT1(.XMLRTN,TYPE)
 I '$O(XMLRTN("")) K RESULTS("mime") D SETERROR^VPRJRUT(404,"MOCHA sub service not found")
 D ADDCRLF^VPRJRUT(.XMLRTN)
 M RESULTS=XMLRTN
 QUIT
 ;
POSTTEST(ARGS,BODY,RESULT) ; POST XML to a WP field in Fileman; handles /xmlpost
 N IEN S IEN=$O(^%W(6.6002,""),-1)+1
 N %WFDA S %WFDA(6.6002,"?+1,",.01)=IEN D UPDATE^DIE("",$NA(%WFDA))
 S RESULT="/fileman/6.6002/"_IEN_"/"_1 ; Stored URL
 N PARSED ; Parsed array which stores each line on a separate node.
 D PARSE10^VPRJRUT(.BODY,.PARSED) ; Parser
 D WP^DIE(6.6002,IEN_",",1,"K",$NA(PARSED)) ; File WP field; lock record in process.
 ; ZSHOW "V":^KBANPARSED
 S RESULT("mime")="text/plain; charset=utf-8" ; Character set of the return URL
 Q RESULT
 ;
MOCHAP(ARGS,BODY,RESULT) ; POST XML to MOCHA; handles MOCHA/ordercheck
 ; N TYPE S TYPE=$G(ARGS("type"))
 N DIQUIET S DIQUIET=1 D DT^DICRW
 N PARSEDTEXT D PARSE10^VPRJRUT(.BODY,.PARSEDTEXT)
 ; K ^KBANPARSED M ^KBANPARSED=PARSEDTEXT
 ; D GETXRSP^KBAIT1(.RESULT,TYPE)
 ;
 ; Put the parsed XML in a global
 N R S R=$NA(^TMP($J,"MOCHA","ORDERCHECK"))
 K @R 
 M @R=PARSEDTEXT
 ;
 ; Parse it
 N DOCHANDLE S DOCHANDLE=$$EN^MXMLDOM(R,"W")
 I 'DOCHANDLE D SETERROR^VPRJRUT("500","XML not parsable") Q ""
 ;
 ; Process it
 D EN^KBANMOCHA(.RESULT,DOCHANDLE)
 ; ZSHOW "*":^KBANPARSED
 ;
 ; Clean-up
 D DELETE^MXMLDOM(DOCHANDLE)
 K @R
 Q ""
 ;
RPC(ARGS,BODY,RESULT) ; POST to execute Remote Procedure Calls; handles POST rpc/{rpc}
 ; Very simple... no security checking
 N RP S RP=$G(ARGS("rpc"))
 I '$L(RP) D SETERROR^VPRJRUT("400","Remote procedure not specified") Q ""
 ;
 N DIQUIET S DIQUIET=1 D DT^DICRW ; Set up "^" as U
 ;
 N XWB
 S XWB(2,"RPC")=RP
 N % S %=$$RPC^XWBPRS()
 I % D SETERROR^VPRJRUT("404","Remote procedure not found") Q ""
 ;
 N PARAMS,%WERR
 I $D(BODY) D DECODE^VPRJSON($NA(BODY),$NA(PARAMS),$NA(%WERR))
 I $D(%WERR) D SETERROR^VPRJRUT("400","Input parameters not correct")
 ;
 ; Loop through the PARAMS and construct an argument list
 ; TODO: Two uncommonly used types are global and reference parameter. Need to do if we want to emulate broker completely.
 N ARGLIST S ARGLIST=""  ; Argument list, starting empty
 ;
 I $D(PARAMS) F I=1:1:$O(PARAMS(""),-1) N @("A"_I)  ; New parameter variables, stored in A1,A2,A3 etc.
 D:$D(PARAMS)
 . N I F I=0:0 S I=$O(PARAMS(I)) Q:'I  D
 . . I $D(PARAMS(I))[0 D  ; Reference Parameter
 . . . M @("A"_I)=PARAMS(I) S ARGLIST=ARGLIST_".A"_I_","
 . . E  D  ; Literal Param
 . . . S @("A"_I)=PARAMS(I),ARGLIST=ARGLIST_"A"_I_","
 ;
 S ARGLIST=$E(ARGLIST,1,$L(ARGLIST)-1) ; Remove trailing comma
 ;
 N %WCALL 
 I $L(ARGLIST) S %WCALL="D "_XWB(2,"RTAG")_"^"_XWB(2,"RNAM")_"(.RESULT,"_ARGLIST_")" ; Routine call with arguments
 E  S %WCALL="D "_XWB(2,"RTAG")_"^"_XWB(2,"RNAM")_"(.RESULT)" ; Routine call with no arguments
 ;
 X %WCALL ; Action!
 ;
 D ADDCRLF^VPRJRUT(.RESULT) ; Add CRLF to each line
 ;
 ; debug
 ;K ^KBANRPC 
 ;M ^KBANRPC=BODY,^KBANRPC=RP
 ;ZSHOW "V":^KBANRPC
 ; debug
 ;
 S RESULT("mime")="text/plain; charset=utf-8" ; Character set of the return
 Q "/rpc/"_RP
 ;
RPCO(RESULT,ARGS) ; Get Remote Procedure Information; handles OPTIONS rpc/{rpc}
 ; Very simple... no security checking
 N RP S RP=$G(ARGS("rpc"))
 I '$L(RP) D SETERROR^VPRJRUT("400","Remote procedure not specified") Q
 ;
 N RPIEN S RPIEN=$$FIND1^DIC(8994,,"QX",RP,"B") ; Find eXact, Quick (no transforms) in B index
 I 'RPIEN D SETERROR^VPRJRUT("404","Remote procedure not found") Q
 ;
 ;
 N %WRTN,%WERR
 D GETS^DIQ(8994,RPIEN,"**","RN",$NA(%WRTN)) ; Get all fields; resolve to external names and omit nulls
 N ROU,TAG S ROU=%WRTN(8994,RPIEN_",","ROUTINE"),TAG=%WRTN(8994,RPIEN_",","TAG")
 I $L($T(@(TAG_"^"_ROU))) S %WRTN(8994,RPIEN_",","FORMALLINE")=$T(@(TAG_"^"_ROU))
 D ENCODE^VPRJSON($NA(%WRTN(8994,RPIEN_",")),$NA(RESULT),$NA(%WERR))
 ; debug
 ;K ^KBANRPC 
 ;S ^KBANRPC=RP
 ;ZSHOW "V":^KBANRPC
 ; debug
 I $D(%WERR) D SETERROR^VPRJRUT("500","Error in JSON conversion") Q
 ;
 QUIT
 ;
FILESYS(RESULT,ARGS) ; Handle filesystem/*
 N PATH
 ;
 ; Vhere is our home? If any home!
 I $D(^%WHOME)#2 D
 . I +$SY=47 S $ZD=^%WHOME ; GT.M
 . I +$SY=0 N % S %=$ZU(168,^%WHOME) ; Cache
 ;
 ; Ok, get the actual path
 I +$SY=47 S PATH=$ZDIRECTORY_ARGS("*") ; GT.M Only!
 I +$SY=0 S PATH=$ZU(168)_ARGS("*") ; Cache Only!
 ;
 ; GT.M errors out on FNF; Cache blocks. Need timeout and else.
 N $ET S $ET="G FILESYSE"
 ; Fixed prevents Reads to terminators on SD's. CHSET makes sure we don't analyze UTF.
 I +$SY=47 O PATH:(REWIND:READONLY:FIXED:CHSET="M") 
 ;
 ; This mess for Cache!
 N POP S POP=0
 I +$SY=0 O PATH:("RU"):0  E  S POP=1  ; Cache must have a timeout; U = undefined.
 I POP G FILESYSE
 ;
 ; Prevent End of file Errors for Cache. Set DSM mode for that.
 I +$SY=0 D $SYSTEM.Process.SetZEOF(1) ; Cache stuff!!
 ;
 ; Get mime type
 ; TODO: Really really needs to be in a file
 N EXT S EXT=$P(PATH,".",$L(PATH,"."))
 I $E(EXT,1,3)="htm" S RESULT("mime")="text/html"
 I EXT="js" S RESULT("mime")="application/javascript"
 I EXT="css" S RESULT("mime")="text/css"
 I EXT="pdf" S RESULT("mime")="application/pdf"
 ;
 ; Read operation
 U PATH
 N C S C=1
 N X F  R X#4079:0 S RESULT(C)=X,C=C+1 Q:$ZEOF
 C PATH
 QUIT
 ;
FILESYSE ; 500
 S $EC=""
 D SETERROR^VPRJRUT("500",$S(+$SY=47:$ZS,1:$ZE))
 QUIT

%WC
%WC ; VEN/SMH - Web Services Client using cURL ;2013-10-31  6:18 PM
 ; See accompanying License for terms of use.
 ;
%(RETURN,METHOD,URL,PAYLOAD,MIME,TO,HEADERS) ; General call for any type
 ;
 ;
 ; DEBUG; Test error trapping.
 ; N X S X=1/0
 ; DEBUG
 ;
 ;
 S TO=$G(TO) ; Timeout
 I +TO=0 S TO=30 ; Default timeout
 ;
 ; Write payload to File in shared memory
 I $D(PAYLOAD) N F D
 . S F="/dev/shm/"_$R(987987234)_$J_".DAT"
 . O F:(NEWVERSION) U F
 . I $D(PAYLOAD)#2 W PAYLOAD,!
 . N I F I=0:0 S I=$O(PAYLOAD(I)) Q:'I  W PAYLOAD(I),!
 . C F
 ;
 N CMD S CMD="curl -K -" ; Read options from stdin; GT.M cannot handle a command longer than 255 characters.
 ;
 ; DEBUG ; See if we can get an error if curl isn't found on the Operating System.
 ;N CMD S CMD="curly -si -XPOST --connect-timeout "_TO_" -m "_TO_" -k "_URL_" --header 'Content-Type:"_MIME_"'"_" --data-binary @"_F
 ; DEBUG
 ;
 ; DEBUG
 ; W !,CMD
 ; DEBUG
 ;
 ; TODO: Check curl return status. VEN/SMH - Seems that there is no way to get that from GT.M right now.
 ; VEN/SMH - confirmed with Bhaskar that GT.M doesn't have a way check return status.
 ;
 ; VEN/SMH Okay. This the code is hard to understand. See comments.
 ;
 ; Execute and read back
 N D S D="cURLDevice"
 O D:(shell="/bin/sh":command=CMD:PARSE)::"PIPE" U D
 ;
 ; Write what to do for curl -K -
 ; TODO: not bullet proof. Some characters may need to be escaped.
 N Q S Q=""""
 W "url = ",Q_URL_Q,!
 W "request = ",METHOD,!
 W "connect-timeout = ",TO,!
 W "max-time = ",TO,!
 W "insecure",!
 W "silent",!
 W "include",!
 I $D(MIME)#2 W "header = "_Q_"Content-Type: "_MIME_Q,!
 I $D(PAYLOAD) W "data-binary = "_Q_"@"_F_Q,!
 W /EOF
 ;
 ; Flag to indicate whether a line we are getting a header or not. We are getting headers first, so it's true.
 ; A la State machine.
 N ISHEADER S ISHEADER=1 
 N I F I=1:1 R RETURN(I)#4000:1 Q:$ZEOF  D   ; Read each line up to 4000 characters
 . S RETURN(I)=$$TRIM(RETURN(I),,$C(13)) ; Strip CRs (we are on Unix)
 . I RETURN(I)="",$G(HEADERS("STATUS")) S ISHEADER=0  ; If we get a blank line, and we don't have a status yet (e.g. if we got a 100 which we kill off), we are no longer at the headers
 . I ISHEADER D  QUIT                    ; If we are at the headers, read them & remove them from RETURN array.
 . . ; First Line is like HTTP/1.1 200 OK
 . . I RETURN(I)'[":" S HEADERS("PROTOCOL")=$P(RETURN(I)," "),HEADERS("STATUS")=$P(RETURN(I)," ",2) K RETURN(I)
 . . ; Next lines are key: value pairs. 
 . . E  S HEADERS($P(RETURN(I),":"))=$$TRIM($P(RETURN(I),":",2,99)) K RETURN(I)
 . . I HEADERS("STATUS")=100 K HEADERS("PROTOCOL"),HEADERS("STATUS") QUIT  ; We don't want the continue
 . K:RETURN(I)="" RETURN(I) ; remove empty line
 K:RETURN(I)="" RETURN(I)  ; remove empty line (last line when $ZEOF gets hit)
 C D
 
 ; Delete the file a la %ZISH
 I $D(PAYLOAD) O F C F:(DELETE)
 ;
 ; Comment the zwrites out to see the return vales from the function
 ;DEBUG
 ; ZWRITE HEADERS
 ; ZWRITE RETURN
 ;DEBUG
 ;
 QUIT
 ;
 ;
POST(RETURN,URL,PAYLOAD,MIME,TO,HEADERS) ; Post
 ;D EWD(.RETURN,URL,.PAYLOAD,MIME)
 D CURL(.RETURN,URL,.PAYLOAD,MIME,TO,.HEADERS)
 QUIT
 ;
EWD(RETURN,URL,PAYLOAD,MIME,TO,HEADERS) ; Post using EWD
 N OK S OK=$$httpPOST^%zewdGTM(URL,.PAYLOAD,MIME,.RETURN)
 QUIT
 ;
CURL(RETURN,URL,PAYLOAD,MIME,TO,HEADERS) ; Post using CURL
 ;
 ; DEBUG; Test error trapping.
 ; N X S X=1/0
 ; DEBUG
 ;
 ;
 S TO=$G(TO) ; Timeout
 I +TO=0 S TO=30 ; Default timeout
 ;
 ; Write payload to File in shared memory
 N F S F="/dev/shm/"_$R(987987234)_$J_".DAT"
 O F:(NEWVERSION) U F
 I $D(PAYLOAD)#2 W PAYLOAD,!
 N I F I=0:0 S I=$O(PAYLOAD(I)) Q:'I  W PAYLOAD(I),!
 C F
 ;
 ; Flags: -s : Silent; -X: HTTP POST; -k : Ignore certificate validation.
 ; --connect-timeout: try only for this long; -m: max time to try. Both in sec.
 ; -i: Print headers out in response.
 N CMD S CMD="curl -si -XPOST --connect-timeout "_TO_" -m "_TO_" -k "_URL_" --header 'Content-Type:"_MIME_"'"_" --data-binary @"_F
 ;
 ;
 ; DEBUG ; See if we can get an error if curl isn't found on the Operating System.
 ;N CMD S CMD="curly -si -XPOST --connect-timeout "_TO_" -m "_TO_" -k "_URL_" --header 'Content-Type:"_MIME_"'"_" --data-binary @"_F
 ; DEBUG
 ;
 ; DEBUG
 ; W !,CMD
 ; DEBUG
 ;
 ; TODO: Check curl return status. VEN/SMH - Seems that there is no way to get that from GT.M right now.
 ; VEN/SMH - confirmed with Bhaskar that GT.M doesn't have a way check return status.
 ;
 ; VEN/SMH Okay. This the code is hard to understand. See comments.
 ;
 ; Execute and read back
 N D S D="cURLDevice"
 O D:(shell="/bin/sh":command=CMD:PARSE)::"PIPE" U D
 ;
 ;
 ; Flag to indicate whether a line we are getting a header or not. We are getting headers first, so it's true.
 ; A la State machine.
 N ISHEADER S ISHEADER=1 
 N I F I=1:1 R RETURN(I)#4000:1 Q:$ZEOF  D   ; Read each line up to 4000 characters
 . S RETURN(I)=$$TRIM(RETURN(I),,$C(13)) ; Strip CRs (we are on Unix)
 . I RETURN(I)="",$G(HEADERS("STATUS")) S ISHEADER=0  ; If we get a blank line, and we don't have a status yet (e.g. if we got a 100 which we kill off), we are no longer at the headers
 . I ISHEADER D  QUIT                    ; If we are at the headers, read them & remove them from RETURN array.
 . . ; First Line is like HTTP/1.1 200 OK
 . . I RETURN(I)'[":" S HEADERS("PROTOCOL")=$P(RETURN(I)," "),HEADERS("STATUS")=$P(RETURN(I)," ",2) K RETURN(I)
 . . ; Next lines are key: value pairs. 
 . . E  S HEADERS($P(RETURN(I),":"))=$$TRIM($P(RETURN(I),":",2,99)) K RETURN(I)
 . . I HEADERS("STATUS")=100 K HEADERS("PROTOCOL"),HEADERS("STATUS") QUIT  ; We don't want the continue
 . K:RETURN(I)="" RETURN(I) ; remove empty line
 K:RETURN(I)="" RETURN(I)  ; remove empty line (last line when $ZEOF gets hit)
 C D
 
 ; Delete the file a la %ZISH
 O F C F:(DELETE)
 ;
 ; Comment the zwrites out to see the return vales from the function
 ;DEBUG
 ; ZWRITE HEADERS
 ; ZWRITE RETURN
 ;DEBUG
 ;
 QUIT
 ;
 ; Code below stolen from Kernel. Thanks Wally.
TRIM(%X,%F,%V) ;Trim spaces\char from front(left)/back(right) of string
 N %R,%L
 S %F=$$UP($G(%F,"LR")),%L=1,%R=$L(%X),%V=$G(%V," ")
 ;I %F["R" F %R=$L(%X):-1:1 Q:$E(%X,%R)'=%V  ;take out BT
 I %F["R" F %R=$L(%X):-1:0 Q:$E(%X,%R)'=%V  ;598
 ;I %F["L" F %L=1:1:$L(%X) Q:$E(%X,%L)'=%V  ;take out BT
 I %F["L" F %L=1:1:$L(%X)+1 Q:$E(%X,%L)'=%V  ;598
 I (%L>%R)!(%X=%V) Q ""
 Q $E(%X,%L,%R)
 ;
UP(X) Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
 ;
TEST ; Unit Tests
 ; Test Get
 N RTN,H D %(.RTN,"GET","https://thebes.smh101.com/r/DIC",,"application/text",5,.H)
 I H("STATUS")'=200 WRITE "FAIL FAIL FAIL",!
 ;
 ; Test Put
 N PAYLOAD,RTN,H
 N R S R=$R(123423421234)
 S PAYLOAD(1)="KBANTEST ; VEN/SMH - Test routine for Sam ;"_R
 S PAYLOAD(2)=" QUIT"
 D %(.RTN,"PUT","https://thebes.smh101.com/r/KBANTEST",.PAYLOAD,"application/text",5,.H)
 I H("STATUS")'=201 WRITE "FAIL FAIL FAIL",!
 ;
 ; Test Get with no mime and no headers to return
 N RTN,H D %(.RTN,"GET","https://thebes.smh101.com/r/KBANTEST")
 I $P(@$Q(RTN),";",3)'=R W "FAIL FAIL FAIL",!
 ;
 QUIT

%WHOME
%WHOME ; VEN/SMH - Home page processor; 25 NOV 2013
 ;;
 ;
EN(RESULT) ; PEP
 S RESULT("mime")="text/html; charset=utf-8"
 N CRLF S CRLF=$C(13,10)
 N I F I=1:1 S RESULT(I)=$P($TEXT(HTML+I),";;",2,99) Q:RESULT(I)=""  D
 . I RESULT(I)["<%TABLEDATA%>" D
 .. N IEN S IEN=0 F J=I:.0001 S IEN=$O(^%W(17.6001,IEN)) Q:'IEN  D
 ... S RESULT(J)="<tr>",J=J+.0001
 ... S RESULT(J)="<td>"_^%W(17.6001,IEN,0)_"</td>",J=J+.0001
 ... S RESULT(J)="<td>"_^%W(17.6001,IEN,1)_"</td>",J=J+.0001
 ... ;
 ... N EP S EP=^%W(17.6001,IEN,2) N RTN S RTN=$P(EP,"^",2),RTN=$$URLENC^VPRJRUT(RTN)
 ... S RESULT(J)="<td><a href=""r/"_RTN_""">"_EP_"</td>",J=J+.0001
 ... ;
 ... N AUTH S AUTH=$P($G(^%W(17.6001,IEN,"AUTH")),"^",1),AUTH=$S(AUTH:"YES",1:"NO")
 ... S RESULT(J)="<td>"_AUTH_"</td>",J=J+.0001
 ... ;
 ... N KEY S KEY=$P($G(^%W(17.6001,IEN,"AUTH")),"^",2) I KEY S KEY=$P($G(^DIC(19.1,KEY,0)),"^")
 ... S RESULT(J)="<td>"_KEY_"</td>",J=J+.0001
 ... ;
 ... N RKEY S RKEY=$P($G(^%W(17.6001,IEN,"AUTH")),"^",3) I RKEY S RKEY=$P($G(^DIC(19.1,RKEY,0)),"^")
 ... S RESULT(J)="<td>"_RKEY_"</td>",J=J+.0001
 ... ;
 ... N OPT S OPT=$P($G(^%W(17.6001,IEN,"AUTH")),"^",4) I OPT S OPT=$P($G(^DIC(19,OPT,0)),"^")
 ... S RESULT(J)="<td>"_OPT_"</td>",J=J+.0001
 ... ;
 ... S RESULT(J)="</tr>"
 . I RESULT(I)="<%FOOTER%>" D
 .. S RESULT(I)="$JOB="_$J_" | $SYSTEM="_$SYSTEM_" | ^DD(""SITE"")="_$G(^DD("SITE"))
 .. S RESULT(I)=RESULT(I)_" | ^DD(""SITE"",1)="_$G(^DD("SITE",1))
 . S RESULT(I)=RESULT(I)_CRLF
 KILL RESULT(I) ; Kill last one which is empty.
 QUIT
 ;
HTML ; HTML to Write out
 ;;<!doctype html>
 ;;<html>
 ;;<head>
 ;;<title>MUMPS Restful Web-Services Portal</title>
 ;;<style>
 ;; body {
 ;;     margin: 0 0 0 0;
 ;;     font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
 ;;     font-size: 14px;
 ;;     line-height: 1.428571429;
 ;;     background-color: rgb(245, 217, 181)
 ;; }
 ;; header {
 ;;     background-color: rgb(92, 81, 37);
 ;;     box-sizing: border-box;
 ;;     color: rgb(253, 252, 245);
 ;;     text-align: center;
 ;;     vertical-align: middle;
 ;;     padding-top: 1.2em;
 ;;     padding-bottom: 0.5em;
 ;;     position: fixed;
 ;;     top: 0;
 ;;     right: 0;
 ;;     left: 0;
 ;;     }
 ;; header > span {
 ;;     font-size: 3em;
 ;;     line-height: 1em;
 ;; }
 ;; footer {
 ;;     background-color: black;
 ;;     box-sizing: border-box;
 ;;     color: white;
 ;;     #position: fixed;
 ;;     #bottom: 0;
 ;;     width: 100%;
 ;;     text-align: center;
 ;;     }
 ;; main {
 ;;     box-sizing: border-box;
 ;;     display: block;
 ;;     font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
 ;;     padding-bottom: 140px;
 ;;     padding-left: 15px;
 ;;     padding-right: 15px;
 ;;     padding-top: 140px;
 ;;     text-align: left;
 ;;     text-shadow: rgba(0, 0, 0, 0.14902) 0px 1px 0px;
 ;; }
 ;; table, td, tr, th {
 ;;     border: 1px solid black;
 ;;     border-collapse:collapse;
 ;;     padding: 15px;
 ;; }
 ;;</style>
 ;;</head>
 ;;<body>
 ;;<header>
 ;; <span>MUMPS Restful Web-Services Portal</span>
 ;;</header>
 ;;<main>
 ;;<p>
 ;; Welcome to the MUMPS Advanced Shell Web Services.
 ;;</p>
 ;;<p>
 ;; Here is a list of web services configured on this server.
 ;; <table>
 ;;  <tr>
 ;;   <th>HTTP VERB</th>
 ;;   <th>URI</th>
 ;;   <th>Execution Endpoint</th>
 ;;   <th>Authentication Required?</th>
 ;;   <th>Security Key</th>
 ;;   <th>Reverse Key</th>
 ;;   <th>Access to Option</th> 
 ;;   <th>Example Call</th>
 ;;   <th>Description</th>
 ;;  </tr>
 ;;    <%TABLEDATA%>
 ;; </table>
 ;;</p>
 ;;</main>
 ;;<footer>
 ;;<span>
 ;;<%FOOTER%>
 ;;</span>
 ;;</footer>
 ;;</body>
 ;;</html>

%WINI001
%WINI001 ; ; 22-NOV-2013
 ;;0.2;MASH WEB SERVER;;NOV 22, 2013
 Q:'DIFQ(17.6001)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,999) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^DIC(17.6001,0,"GL")
 ;;=^%W(17.6001,
 ;;^DIC("B","WEB SERVICE URL HANDLER",17.6001)
 ;;=
 ;;^DD(17.6001,0)
 ;;=FIELD^^14^7
 ;;^DD(17.6001,0,"DT")
 ;;=3130507
 ;;^DD(17.6001,0,"NM","WEB SERVICE URL HANDLER")
 ;;=
 ;;^DD(17.6001,.01,0)
 ;;=HTTP VERB^RS^POST:POST;PUT:PUT;GET:GET;DELETE:DELETE;OPTIONS:OPTIONS;HEAD:HEAD;TRACE:TRACE;CONNECT:CONNECT;^0;1^Q
 ;;^DD(17.6001,.01,1,0)
 ;;=^.1^^0
 ;;^DD(17.6001,.01,3)
 ;;=
 ;;^DD(17.6001,.01,"DT")
 ;;=3130327
 ;;^DD(17.6001,1,0)
 ;;=URI^F^^1;E1,250^K:$L(X)>250!($L(X)<1) X
 ;;^DD(17.6001,1,3)
 ;;=
 ;;^DD(17.6001,1,"DT")
 ;;=3130327
 ;;^DD(17.6001,2,0)
 ;;=EXECUTION ENDPOINT^F^^2;E1,250^K:$L(X)>250!($L(X)<1) X
 ;;^DD(17.6001,2,3)
 ;;=
 ;;^DD(17.6001,2,"DT")
 ;;=3130327
 ;;^DD(17.6001,11,0)
 ;;=AUTHENTICATION REQUIRED?^S^1:YES;^AUTH;1^Q
 ;;^DD(17.6001,11,"DT")
 ;;=3130506
 ;;^DD(17.6001,12,0)
 ;;=KEY^P19.1'^DIC(19.1,^AUTH;2^Q
 ;;^DD(17.6001,12,"DT")
 ;;=3130506
 ;;^DD(17.6001,13,0)
 ;;=REVERSE KEY^P19.1'^DIC(19.1,^AUTH;3^Q
 ;;^DD(17.6001,13,"DT")
 ;;=3130507
 ;;^DD(17.6001,14,0)
 ;;=OPTION^P19'^DIC(19,^AUTH;4^Q
 ;;^DD(17.6001,14,"DT")
 ;;=3130506
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",0)
 ;;=17.6001^B^Uniqueness Index for Key 'A' of File #17.6001^R^^R^IR^I^17.6001^^^^^LS
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",1)
 ;;=S ^%W(17.6001,"B",X(1),X(2),X(3),DA)=""
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",2)
 ;;=K ^%W(17.6001,"B",X(1),X(2),X(3),DA)
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",2.5)
 ;;=K ^%W(17.6001,"B")
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",11.1,0)
 ;;=^.114IA^3^3
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",11.1,1,0)
 ;;=1^F^17.6001^.01^^1
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",11.1,2,0)
 ;;=2^F^17.6001^1^^2
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",11.1,3,0)
 ;;=3^F^17.6001^2^^3
 ;;^UTILITY("KX",$J,"KEY",17.6001,17.6001,"A",0)
 ;;=17.6001^A^P^897
 ;;^UTILITY("KX",$J,"KEY",17.6001,17.6001,"A",2,0)
 ;;=^.312IA^3^3
 ;;^UTILITY("KX",$J,"KEY",17.6001,17.6001,"A",2,1,0)
 ;;=.01^17.6001^1
 ;;^UTILITY("KX",$J,"KEY",17.6001,17.6001,"A",2,2,0)
 ;;=1^17.6001^2
 ;;^UTILITY("KX",$J,"KEY",17.6001,17.6001,"A",2,3,0)
 ;;=2^17.6001^3
 ;;^UTILITY("KX",$J,"KEYPTR",17.6001,17.6001,"A")
 ;;=176.801^SID

%WINI002
%WINI002 ; ; 22-NOV-2013
 ;;0.2;MASH WEB SERVER;;NOV 22, 2013
 I DSEC F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,999) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^DIC(17.6001,0,"AUDIT")
 ;;=@
 ;;^DIC(17.6001,0,"DD")
 ;;=@
 ;;^DIC(17.6001,0,"DEL")
 ;;=@
 ;;^DIC(17.6001,0,"LAYGO")
 ;;=@
 ;;^DIC(17.6001,0,"RD")
 ;;=@
 ;;^DIC(17.6001,0,"WR")
 ;;=@

%WINI003
%WINI003 ; ; 22-NOV-2013
 ;;0.2;MASH WEB SERVER;;NOV 22, 2013
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,999) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"SBF",17.6001,17.6001)
 ;;=

%WINIT
%WINIT ; ;2013-11-22  7:59 PM
 ;;0.2;MASH WEB SERVER;;NOV 22, 2013
 ;
 K DIF,DIFQ,DIFQR,DIFQN,DIK,DDF,DDT,DTO,D0,DLAYGO,DIC,DIDUZ,DIR,DA,DIFROM,DFR,DTN,DIX,DZ,DIRUT,DTOUT,DUOUT
 S DIOVRD=1,U="^",DIFQ=0,DIFROM="0.2" W !,"This version (#0.2) of '%WINIT' was created on 22-NOV-2013"
 W !?9,"(at Vista-Office EHR, by VA FILEMAN 22.0)",!
 I $D(^DD("VERSION")),^("VERSION")'<22.0 G GO
 ;W !,"FIRST, I'LL FRESHEN UP YOUR VA FILEMAN...." D N^DINIT
 I ^DD("VERSION")<22.0 W !,"but I need version 22.0 of the VA FileMan!" G Q
GO ;
EN ; ENTER HERE TO BYPASS THE PRE-INIT PROGRAM
 S DIFQ=0 K DIRUT,DTOUT,DUOUT
 F DIFRIR=1:1:1 S DIFRRTN="^%WINIT"_$E("5",DIFRIR) D @DIFRRTN
 W:1 !,"I AM GOING TO SET UP THE FOLLOWING FILES:" F I=1:2:2 S DIF(I)=^UTILITY("DIF",$J,I) D 1 G Q:DIFQ!$D(DIRUT) K DIF(I)
 S DIFROM="0.2" D PKG:'$D(DIFROM(0)),^%WINIT1 G Q:'$D(DIFQ) S DIK(0)="AB"
 F DIF=1:2:2 S %=^UTILITY("DIF",$J,DIF),DIK=$P(%,";",5),N=$P(%,";",3),D=$P(%,";",4)_U_N D D K DIFQ(N)
 K DIFQR D ^%WINIT2,^%WINIT3
 L  S DUZ=DIDUZ W:1 !,$C(7),"OK, I'M DONE.",!,"NO"_$P("TE THAT FILE",U,DSEC)_" SECURITY-CODE PROTECTION HAS BEEN MADE"
 I DIFROM F DIF=1:2:2 S %=^UTILITY("DIF",$J,DIF),N=+$P(%,";",3) I N,$P(%,";",8)="y" S ^DD(N,0,"VR")=DIFROM
 I DIFROM(0)>0 F %="PRE","INI","INIT" S:$D(DIFROM(%)) $P(^DIC(9.4,DIFROM(0),%),U,2)=DIFROM(%)
 I $G(DIFQN) S $P(^(0),U,3,4)=$P(DIFQN,U,2)_U_($P(^DIC(0),U,4)+DIFQN) K DIFQN
 S:DIFROM(0)>0 ^DIC(9.4,DIFROM(0),"VERSION")=DIFROM G Q^DIFROM0
D S:$D(^DIC(+N,0))[0 ^(0)=D S X=$D(@(DIK_"0)")),^(0)=D_U_$S(X#2:$P(^(0),U,3,9),1:U)
 S DIFQR=DIFQR(+N) I ^DD("VERSION")>17.5,$D(^DD(+N,0,"DIK"))#2 S X=^("DIK"),Y=+N,DMAX=^DD("ROU") D EN^DIKZ
 I DIFQR D IXALL^DIK:$O(@(DIK_"0)")) W "."
 Q
R G REP^%WINIT2
 ;
1 S N=+$P(DIF(I),";",3),DIF=$P(DIF(I),";",4),S=$P(DIF(I),";",5)
 W !!?3,N,?13,DIF,$P("  (Partial Definition)",U,$P(DIF(I),";",6)),$P("  (including data)",U,$P(DIF(I),";",13)="y") S Z=$S($D(^DIC(N,0))#2:^(0),1:"")
 I Z="" S DIFQ(N)=1,DIFQN=$G(DIFQN)+1_U_N G S
 I $L($P(Z,DIF)) W $C(7),!,"*BUT YOU ALREADY HAVE '",$P(Z,U),"' AS FILE #",N,"!" D R Q:DIFQ  G S:$D(DIFKEP(N)),1
 S DIFQ(N)=$P(DIF(I),";",7)'="n"
 I $L(Z) W $C(7),!,"Note:  You already have the '",$P(Z,U),"' File." S DIFQ(0)=1
 S %=$E(^UTILITY("DIF",$J,I+1),4,245) I %]"" X % S DIFQ(N)=$T W:'$T !,"Screen on this Data Dictionary did not pass--DD will not be installed!" G S
 I $L(Z),$P(DIF(I),";",10)="y" S DIR("A")="Shall I write over the existing Data Definition",DIR("??")="^D DD^DIFROMH1",DIR("B")="YES",DIR(0)="Y" D ^DIR S DIFQ(N)=Y
S S DIFQR(N)=0 Q:$P(DIF(I),";",13)'="y"!$D(DIRUT)
 I $P(DIF(I),";",15)="y",$O(@(S_"0)"))>0 S DIF=$P(DIF(I),";",14)="o",DIR("A")="Want my data "_$P("merged with^to overwrite",U,DIF+1)_" yours",DIR("??")="^D DTA^DIFROMH1",DIR(0)="Y" D ^DIR S DIFQR(N)=$S('Y:Y,1:Y+DIF) Q
 S %=$P(DIF(I),";",14)="o" W !,$C(7),"I will ",$P("MERGE^OVERWRITE",U,%+1)," your data with mine." S DIFQR(N)=%+1
 Q
Q W $C(7),!!,"NO UPDATING HAS OCCURRED!" G Q^DIFROM0
 ;
PKG S X=$P($T(IXF),";",3),DIC="^DIC(9.4,",DIC(0)="",DIC("S")="I $P(^(0),U,2)="""_$P(X,U,2)_"""",X=$P(X,U) D ^DIC S DIFROM(0)=+Y K DIC
 Q
 ;
IXF ;;;1

%WINIT1
%WINIT1 ; ; 22-NOV-2013
 ;;0.2;MASH WEB SERVER;;NOV 22, 2013
 ; LOADS AND INDEXES DD'S
 ; Modified to be silent by VEN/SMH
 ;
 K DIF,DIK,D,DDF,DDT,DTO,D0,DLAYGO,DIC,DIDUZ,DIR,DA,DFR,DTN,DIX,DZ D DT^DICRW S %=1,U="^",DSEC=1
 S NO=$P("I 0^I $D(@X)#2,X[U",U,%) I %<1 K DIFQ Q
ASK ; I %=1,$D(DIFQ(0)) W !,"SHALL I WRITE OVER FILE SECURITY CODES" S %=2 D YN^DICN S DSEC=%=1 I %<1 K DIFQ Q
 Q:'$D(DIFQ)  ; S %=2 W !!,"ARE YOU SURE EVERYTHING'S OK" D YN^DICN I %-1 K DIFQ Q
 I $D(DIFKEP) F DIDIU=0:0 S DIDIU=$O(DIFKEP(DIDIU)) Q:DIDIU'>0  S DIU=DIDIU,DIU(0)=DIFKEP(DIDIU) D EN^DIU2
 D DT^DICRW K ^UTILITY(U,$J),^UTILITY("DIK",$J) D WAIT^DICD
 S DN="^%WINI" F R=1:1:3 D @(DN_$$B36(R)) W "."
 F  S D=$O(^UTILITY(U,$J,"SBF","")) Q:D'>0  K:'DIFQ(D) ^(D) S D=$O(^(D,"")) I D>0  K ^(D) D IX
KEYSNIX ; Keys and new style indexes installer ; new in FM V22.2
 N DIFRSA S DIFRSA=$NA(^UTILITY("KX",$J)) ; Tran global for Keys and Indexes
 N DIFRFILE S DIFRFILE=0 ; Loop through files
 F  S DIFRFILE=$O(@DIFRSA@("IX",DIFRFILE)) Q:'DIFRFILE  D
 . K ^TMP("DIFROMS2",$J,"TRIG")
 . N DIFRD S DIFRD=0
 . F  S DIFRD=$O(@DIFRSA@("IX",DIFRFILE,DIFRD)) Q:'DIFRD  D DDIXIN^DIFROMSX(DIFRFILE,DIFRD,DIFRSA) ; install New Style Indexes
 . K ^TMP("DIFROMS2",$J,"TRIG")
 . S DIFRD=0
 . F  S DIFRD=$O(@DIFRSA@("KEY",DIFRFILE,DIFRD)) Q:'DIFRD  D DDKEYIN^DIFROMSY(DIFRFILE,DIFRD,DIFRSA) ; install keys
 K @DIFRSA ; kill off tran global
 ; VEN/SMH v22.2: Below I added a K D1 because it leaks from the call causing the key matching algo to fail.
DATA W "." S (D,DDF(1),DDT(0))=$O(^UTILITY(U,$J,0)) Q:D'>0
 I DIFQR(D) S DTO=0,DMRG=1,DTO(0)=^(D),Z=^(D)_"0)",D0=^(D,0),@Z=D0,DFR(1)="^UTILITY(U,$J,DDF(1),D0,",DKP=DIFQR(D)'=2 F D0=0:0 S D0=$O(^UTILITY(U,$J,DDF(1),D0)) S:D0="" D0=-1 K D1 Q:'$D(^(D0,0))  S Z=^(0) D I^DITR
 K ^UTILITY(U,$J,DDF(1)),DDF,DDT,DTO,DFR,DFN,DTN G DATA
 ;
W S Y=$P($T(@X),";",2) W !,"NOTE: This package also contains "_Y_"S",! Q:'$D(DIFQ(0))
 S %=1 W ?6,"SHALL I WRITE OVER EXISTING "_Y_"S OF THE SAME NAME" D YN^DICN I '% W !?6,"Answer YES to replace the current "_Y_"S with the incoming ones." G W
 S:%=2 DIFQ(X)=0 K:%<0 DIFQ
 Q
 ;
OPT ;OPTION
RTN ;ROUTINE DOCUMENTATION NOTE
FUN ;FUNCTION
BUL ;BULLETIN
KEY ;SECURITY KEY
HEL ;HELP FRAME
DIP ;PRINT TEMPLATE
DIE ;INPUT TEMPLATE
DIB ;SORT TEMPLATE
DIS ;FORM
REM ;REMOTE PROCEDURE
 ;
SBF ;FILE AND SUB FILE NUMBERS
IX W "." S DIK="A" F %=0:0 S DIK=$O(^DD(D,DIK)) Q:DIK=""  K ^(DIK)
 S DA(1)=D,DIK="^DD("_D_"," D IXALL^DIK
 I $D(^DIC(D,"%",0)) S DIK="^DIC(D,""%""," G IXALL^DIK
 Q
B36(X) Q $$N(X\(36*36)#36+1)_$$N(X\36#36+1)_$$N(X#36+1)
N(%) Q $E("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",%)

%WINIT2
%WINIT2 ; ; 22-NOV-2013
 ;;0.2;MASH WEB SERVER;;NOV 22, 2013
 ;
 ;
 K ^UTILITY("DIFROM",$J),DIC S DIDUZ=0 S:$D(DUZ)#2 DIDUZ=DUZ S DUZ=.5
 I $D(^DIC(9.2,0))#2,^(0)?1"HEL".E S (DIC,DLAYGO)=9.2,N="HEL",DIC(0)="LX" G ADD
 Q
 ;
ADD F R=0:0 S R=$O(^UTILITY(U,$J,N,R)) Q:R'>0  S X=$P(^(R,0),U,1) W "." K DA D ^DIC I Y>0,'$D(DIFQ(N))!$P(Y,U,3) S ^UTILITY("DIFROM",$J,N,X)=+Y K ^DIC(9.2,+Y,1),^(2),^(3),^(10) S %X="^UTILITY(U,$J,N,R,",%Y=DIC_"+Y,",DA=+Y D %XY^%RCR
 S DIK=DIC
HELP S R=$O(^UTILITY("DIFROM",$J,N,R)) Q:R=""  W !,"'"_R_"' Help Frame filed." S DA=^(R)
 F X=0:0 S X=$O(^DIC(9.2,DA,2,X)) Q:'X  S I=$S($D(^(X,0)):^(0),1:0),Y=$P(I,U,2) S:Y]"" Y=$O(^DIC(9.2,"B",Y,0)) S ^(0)=$P(^DIC(9.2,DA,2,X,0),U,1)_U_$S(Y>0:Y,1:"")_U_$P(^(0),U,3,99)
 S I=0 F X=0:0 S X=$O(^DIC(9.2,DA,10,X)) Q:'X  I $D(^(X,0)) S Y=$P(^(0),U),Y=$S(Y]"":$O(^MAG("B",Y,0)),1:0) S:Y $P(^DIC(9.2,DA,10,X,0),U)=Y,I=I+1,%=X I 'Y K ^DIC(9.2,DA,10,X,0)
 I I S $P(^DIC(9.2,DA,10,0),U,3,4)=%_U_I
IX D IX1^DIK G HELP
 ;
U I $D(DIRUT) S DIFQ=1
 W ! Q
REP S DIR(0)="Y",DIR("A")="Shall I change the NAME of the file to "_DIF
 S DIR("??")="^D REP^DIFROMH1",DIR("B")="NO" D ^DIR G U:$D(DIRUT)
 I Y S DIE=1,DIFQ=0,DA=N,DR=".01////"_DIF D ^DIE Q
 S DIR("A")="Shall I replace your file with mine"
 S DIR("??")="^D AG^DIFROMH1" D ^DIR G U:$D(DIRUT)!'Y
 S DIU(0)="E",DIR("A")="Do you want to keep the Data"
 S DIR("??")="^D CHG^DIFROMH1" D ^DIR G U:$D(DIRUT)
 S:'Y DIU(0)=DIU(0)_"D"
 S DIR("A")="Do you want to keep the Templates"
 S DIR("??")="^D TEMP^DIFROMH1" D ^DIR G U:$D(DIRUT) S:'Y DIU(0)=DIU(0)_"T"
 S DIFQ(N)=1,DIFKEP(N)=DIU(0) W !?15," (",DIF,") " Q

%WINIT3
%WINIT3 ; ; 22-NOV-2013
 ;;0.2;MASH WEB SERVER;;NOV 22, 2013
 ;
 ;
 K ^UTILITY("DIFROM",$J) S DIC(0)="LX",(DIC,DLAYGO)=3.6,N="BUL" D ADD:$D(^XMB(3.6,0))
 S X=0 F R=0:0 S X=$O(^UTILITY("DIFROM",$J,N,X)) Q:X=""  W !,"'",X,"' BULLETIN FILED -- Remember to add mail groups for new bulletins."
 I $D(^DIC(9.4,0))#2,^(0)?1"PACK".E S N="PKG",(DIC,DLAYGO)=9.4 D ADD
 G NP:'$D(DA) S %=+$O(^DIC(9.4,DA,22,"B",DIFROM,0)) I $D(^DIC(9.4,DA,22,%,0)) S $P(^(0),U,3)=DT
 I $D(^DIC(9.4,DA,0))#2 S %=$P(^(0),U,4) I %]"" S %=$O(^DIC(9.2,"B",%,0)) S:%]"" $P(^DIC(9.4,DA,0),U,4)=%
OR I $D(^ORD(100.99))&$O(^UTILITY(U,$J,"OR","")) D EN^%WINIT4
NP K DIC,^UTILITY("DIFROM",$J) S DIC(0)="LX" I $D(^DIC(19,0))#2,^(0)?1"OPTION".E S (DIC,DLAYGO)=19,N="OPT" D ADD,OP
 I $D(^DIC(19.1,0))#2,($P(^(0),U)?1"SECUR".E)!($P(^(0),U)="KEY") S (DIC,DLAYGO)=19.1,N="KEY" D ADD K ^UTILITY("DIFROM",$J)
 I $D(^DIC(9.8,0))#2,^(0)?1"ROUTINE^".E S (DIC,DLAYGO)=9.8,N="RTN" D ADD
 S DIC=.5,DLAYGO=0,N="FUN" D ADD
 I $P($G(^DIC(8994,0)),U)="REMOTE PROCEDURE" S (DIC,DLAYGO)=8994,N="REM" D ADD
 S DIC("S")="I $P(^(0),U,4)=DIFL" F N="DIPT","DIBT","DIE" S DIC=U_N_"(" D ADD
 K DIC("S") S N="DIST(.404,",DIC=U_N,DLAYGO=.404 D ADD
 S DIC("S")="I $P(^(0),U,8)=DIFL",N="DIST(.403,",DIC=U_N,DLAYGO=.403 D ADD
 K ^UTILITY(U,$J),DIC,DLAYGO F DIFR="DIE","DIPT" D DIEZ
 K ^UTILITY("DIFROM",$J) Q
DIEZ I ^DD("VERSION")>17.4,'$D(DISYS) D OS^DII
 E  S DISYS=^DD("OS")
 Q:'$D(^DD("OS",DISYS,"ZS"))
 S DIFR1=""
DZ1 S DIFR1=$O(^UTILITY("DIFROM",$J,DIFR,DIFR1)) Q:DIFR1=""
 F DIFR2=0:0 S DIFR2=$O(^UTILITY("DIFROM",$J,DIFR,DIFR1,DIFR2)) Q:'DIFR2  S Y=DIFR2 I $D(@(U_DIFR_"(Y,""ROU"")")) K ^("ROU") I $D(^("ROUOLD")) S X=^("ROUOLD"),DMAX=^DD("ROU") D:X]"" @("EN^DI"_$E(DIFR,3)_"Z")
 G DZ1
 ;
OP S R=$O(^UTILITY("DIFROM",$J,N,R)) I R="" K ^UTILITY("DIFROM",$J) G Q
 W !,"'"_R_"' Option Filed" S DA=+^UTILITY("DIFROM",$J,N,R) G:$P(^(R),U,2,3)="XUCORE^"!($P(^(R),U,2,3)="XUCOMMAND^") OP
 I $D(^DIC(19,DA,220)) S %=$P(^(220),U) S:%]"" %=$O(^XMB(3.6,"B",%,0)) S $P(^DIC(19,DA,220),U)=%,%=$P(^(220),U,3) S:%]"" %=$O(^XMB(3.8,"B",%,0)) S $P(^DIC(19,DA,220),U,3)=%
 S %=$P(^DIC(19,DA,0),U,12) S:%]"" %=$O(^DIC(9.4,"B",%,0))
 S $P(^DIC(19,DA,0),U,12)=%,%=$P(^(0),U,7),(DZ,DIX)=0
 D:$D(^DIC(19,DA,10,"B")) KAD(DA) S:%]"" %=$O(^DIC(9.2,"B",%,0)) S $P(^DIC(19,DA,0),U,7)=%,%=$P(^(0),U,4),%="MOQXL"[% K ^(10,"B"),^("C")
 F X=0:0 S X=$O(^DIC(19,DA,10,X)) Q:'X  S I=$S($D(^(X,0)):^(0),1:0),Y=$S($D(^(U)):^(U),1:"") K ^DIC(19,DA,10,X) I Y]"",% S D=$O(^DIC(19,"B",Y,0)) I D S ^DIC(19,DA,10,X,0)=D_U_$P(I,U,2,9),DZ=DZ+1,DIX=X
 S:% ^DIC(19,DA,10,0)="^19.01PI^"_DIX_U_DZ D IX1^DIK G OP
 ;
ADD F R=0:0 S R=$O(^UTILITY(U,$J,N,R)) Q:R=""  S X=$P(^(R,0),U),DIFL=$S(N="DIST(.403,":$P(^(0),U,8),N="DIST(.404,":$P(^(0),U,2),1:$P(^(0),U,4)) W "." K DA D ^DIC I Y>0,'$D(DIFQ($E(N,1,3)))!$P(Y,U,3) S Y=Y_U D A
Q Q
A I N="BUL" K % S %(0)=$G(@(DIC_"+Y,2,0)")) F %=0:0 S %=$O(@(DIC_"+Y,2,%)")) Q:'%  S %(%)=$G(^(%,0))
 K:N'="KEY"&(N'="OPT") @(DIC_"+Y)") S ^UTILITY("DIFROM",$J,N,X)=Y S:$E(N,1,2)="DI" ^(X,+Y)="" S:N="PKG" DIFROM(0)=+Y Q:$P(Y,U,2,3)="XUCORE^"!($P(Y,U,2,3)="XUCOMMAND^")
 I N="BUL",%(0)]"" S @(DIC_"+Y,2,0)")=%(0) F %=0:0 S %=$O(%(%)) Q:'%  S @(DIC_"+Y,2,%,0)")=%(%)
 I $E(N,1,2)="DI",('DIFL)!('$D(^DD(+DIFL))) D
 .W !,"**WARNING--"_$S(N="DIE":"INPUT",N="DIPT":"PRINT",N="DIBT":"SORT",1:"FORM or BLOCK")_$S(N'["DIST":" template ",1:" ")_$P(Y,U,2)_" has been installed,",!,"but associated file "_DIFL_" is not on your system!"
 .Q
 I N="OPT" S:$P(^DIC(19,+Y,0),U,6)]"" DIOPT=$P(^(0),U,6) I $O(^UTILITY(U,$J,N,R,1,0)) K ^DIC(19,+Y,1)
 I N="DIST(.403," D BLK
 S %X="^UTILITY(U,$J,N,R,",%Y=DIC_"+Y,",DA=+Y,DIK=DIC D %XY^%RCR
 D IX1^DIK:N'="OPT" I N="OPT",$D(DIOPT) S:$P(^DIC(19,DA,0),U,6)="" $P(^(0),U,6)=DIOPT K DIOPT
 I N="DIST(.403," D
 .N DIFRVAL S DIFRVAL=$$VAL^DIFROMSS(.403,DA)
 .I DIFRVAL W !,"Compiling form: ",$P(^DIST(.403,DA,0),U) D EN^DDSZ(DA) Q
 .W !,"ERROR: Form: ",$P(^DIST(.403,DA,0),U)," cannot be compiled"
 .Q
 Q
BLK F J=0:0 S J=$O(^UTILITY(U,$J,N,R,40,J)) Q:'J  I $D(^(J,0)) S %=$P(^(0),U,2) S:%]"" %=$O(^DIST(.404,"B",%,0)) S:% $P(^UTILITY(U,$J,N,R,40,J,0),U,2)=% D B1
 K A0,A1,A2,J,L Q
B1 F L=0:0 S L=$O(^UTILITY(U,$J,N,R,40,J,40,L)) Q:'L  S A0=$G(^(L,0)),%=$P(A0,U) I %]"" S %=$O(^DIST(.404,"B",%,0)) I % S $P(A0,U)=%,^UTILITY(U,$J,N,R,40,J,"BLK",%,0)=A0 D
 .N X S X=0
 .F  S X=$O(^UTILITY(U,$J,N,R,40,J,40,L,X)) Q:X=""  S ^UTILITY(U,$J,N,R,40,J,"BLK",%,X)=^(X)
 .Q
 S A0=$G(^UTILITY(U,$J,N,R,40,J,40,0)) Q:A0=""  K ^UTILITY(U,$J,N,R,40,J,40) S (A1,A2)=0
 F L=0:0 S L=$O(^UTILITY(U,$J,N,R,40,J,"BLK",L)) Q:'L  S ^UTILITY(U,$J,N,R,40,J,40,L,0)=^(L,0),A1=L,A2=A2+1 D
 .N X S X=0
 .F  S X=$O(^UTILITY(U,$J,N,R,40,J,"BLK",L,X)) Q:X=""  S ^UTILITY(U,$J,N,R,40,J,40,L,X)=^(X)
 .Q
 S $P(A0,U,3,4)=A1_U_A2,^UTILITY(U,$J,N,R,40,J,40,0)=A0 K ^UTILITY(U,$J,N,R,40,J,"BLK")
 Q
KAD(D0) N D1,X
 S X=0 F  S X=$O(^DIC(19,D0,10,"B",X)) Q:X'>0  S D1=0 F  S D1=$O(^DIC(19,D0,10,"B",X,D1)) Q:D1'>0  K ^DIC(19,"AD",X,D0,D1)
 Q

%WINIT4
%WINIT4 ; ; 22-NOV-2013
 ;;0.2;MASH WEB SERVER;;NOV 22, 2013
 ;
 ;
EN S DA(1)=1,DIK="^ORD(100.99,1,5," I $D(^ORD(100.99,1,5,DA)) D ^DIK
 S %X="^UTILITY(U,$J,""OR"","_$O(^UTILITY(U,$J,"OR",""))_",",%Y=DIK_DA_","
 S:'$D(^ORD(100.99,1,5,0)) ^(0)="^100.995P^^" S $P(^(0),U,3,4)=DA_U_($P(^(0),U,4)+1)
 D %XY^%RCR S $P(^ORD(100.99,1,5,DA,0),U)=DA,%=$P(^(0),U,4)
 I %]"" S %=$O(^ORD(100.98,"B",%,0)) I %>0 S $P(^ORD(100.99,1,5,DA,0),U,4)=%
 D OR
 S DA(1)=1 D IX1^DIK
 Q
OR S (N,I)=0,X=""
 F  S N=$O(^ORD(100.99,1,5,DA,1,N)) Q:'N  S X=$P(^(N,0),U) I X]"" S %=$O(^ORD(101,"B",X,0)) D:'% ADDP S:% ^ORD(100.99,1,5,DA,1,N,0)=% S X=N,I=I+1,(R,J)=0,Y="" D OR1
 S:I $P(^ORD(100.99,1,5,DA,1,0),U,3,4)=X_U_I S (N,I)=0,X=""
 F  S N=$O(^ORD(100.99,1,5,DA,5,N)) Q:'N  S X=$P(^(N,0),U,3) I X]"" S %=$O(^ORD(101,"B",X,0)) D:'% ADDP S:% $P(^ORD(100.99,1,5,DA,5,N,0),U,3)=% S X=N,I=I+1
 S:I $P(^ORD(100.99,1,5,DA,5,0),U,3,4)=X_U_I K N,R,X,Y,I,J
 Q
OR1 N X F  S R=$O(^ORD(100.99,1,5,DA,1,N,1,R)) Q:'R  S X=$P(^(R,0),U) I X]"" S %=$O(^ORD(101,"B",X,0)) D:'% ADDP S:% ^ORD(100.99,1,5,DA,1,N,1,R,0)=% S Y=R,J=J+1
 S:J $P(^ORD(100.99,1,5,DA,1,N,1,0),U,3,4)=Y_U_J
 Q
ADDP N I,J,N,R,DA,DLAYGO,DO S %=""
 S DIC="^ORD(101,",DIC(0)="LX",DLAYGO=101 D FILE^DICN K DIC Q:Y=-1  S %=+Y Q

%WINIT5
%WINIT5 ; ; 22-NOV-2013
 ;;0.2;MASH WEB SERVER;;NOV 22, 2013
 K ^UTILITY("DIF",$J) S DIFRDIFI=1 F I=1:1:2 S ^UTILITY("DIF",$J,DIFRDIFI)=$T(IXF+I),DIFRDIFI=DIFRDIFI+1
 Q
IXF ;;
 ;;17.6001S;WEB SERVICE URL HANDLER;^%W(17.6001,;0;y;y;;n;;;n
 ;;

VPRJREQ
VPRJREQ ;SLC/KCM -- Listen for HTTP requests;2013-12-27  6:45 PM
 ;;1.0;JSON DATA STORE;;Sep 01, 2012;Build 6
 ;
 ; Listener Process ---------------------------------------
 ; Mods by VEN/SMH for GT.M support.
 ;
GO ; start up REST listener with defaults
 N PORT
 S PORT=$G(^VPRHTTP(0,"port"),9080)
 J START^VPRJREQ(PORT)
 Q
 ;
 ; Convenience entry point
JOB(PORT) J START^VPRJREQ(PORT) QUIT
 ;
START(TCPPORT) ; set up listening for connections
 N %WOS S %WOS=$S(+$SY=47:"GT.M",+$SY=50:"MV1",1:"CACHE") ; Get Mumps Virtual Machine
 I %WOS="GT.M" S @("$ZINTERRUPT=""I $$JOBEXAM^VPRJREQ($ZPOSITION)""")
 ;
 S TCPPORT=$G(TCPPORT,9080)
 ;
 ; Device ID
 I %WOS="CACHE" S TCPIO="|TCP|"_TCPPORT
 I %WOS="GT.M" S TCPIO="SCK$"_TCPPORT
 ;
 ; Open Code
 I %WOS="CACHE" O TCPIO:(:TCPPORT:"ACT"):15 E  U 0 W !,"error cannot open port "_TCPPORT Q
 I %WOS="GT.M" O TCPIO:(ZLISTEN=TCPPORT_":TCP":delim=$C(13,10):attach="server"):15:"socket" E  U 0 W !,"error cannot open port "_TCPPORT Q
 ;
 ; K. Now we are really really listening.
 S ^VPRHTTP(0,"listener")="running"
 ;
 ; This is the same for GT.M and Cache
 U TCPIO
 ;
 I %WOS="GT.M" W /LISTEN(5) ; Listen 5 deep - sets $KEY to "LISTENING|socket_handle|portnumber"
 ;
LOOP ; wait for connection, spawn process to handle it. GOTO favorite.
 I $E(^VPRHTTP(0,"listener"),1,4)="stop" C TCPIO S ^VPRHTTP(0,"listener")="stopped" Q
 ;
 I %WOS="CACHE" D  G LOOP
 . R *X:10
 . E  QUIT  ; Loop back again when listening and nobody on the line
 . J CHILD:(:4:TCPIO:TCPIO):10 ; Send off the device to another job for input and output.
 . i $ZA\8196#2=1 W *-2  ; job failed to clear bit
 ;
 ; In GT.M $KEY is "CONNECT|socket_handle|portnumber" then "READ|socket_handle|portnumber"
 N GTMDONE S GTMDONE=0  ; To tell us if we should loop waiting or process HTTP requests
 I %WOS="GT.M" D  G LOOP:'GTMDONE,CHILD:GTMDONE
 . ;
 . ; Wait until we have a connection. Quit also if the listener asked us to stop.
 . FOR  W /WAIT(10) Q:$KEY]""  Q:($E(^VPRHTTP(0,"listener"),1,4)="stop")
 . ;
 . ; We have to stop! When we quit, we go to loop, and we exit at LOOP+1
 . I $E(^VPRHTTP(0,"listener"),1,4)="stop" QUIT
 . ; 
 . ; If we are at the connect stage, loop around and wait for reads
 . I $P($KEY,"|")="CONNECT" QUIT
 . ;
 . ; Use the incoming socket; close the server, and restart it and goto CHILD
 . USE TCPIO:(SOCKET=$P($KEY,"|",2))
 . CLOSE TCPIO:(SOCKET="server")
 . JOB START^VPRJREQ(TCPPORT):(IN="/dev/null":OUT="/dev/null":ERR="/dev/null"):5
 . SET GTMDONE=1  ; Will goto CHILD at the DO exist up above
 ; 
 QUIT
 ;
JOBEXAM(%ZPOS) ; Interrupt framework for GT.M.
 ZSHOW "*":^VPRHTTP("processlog",+$H,$P($H,",",2),$J)
 QUIT 1
 ;
GTMLNX  ;From Linux xinetd script; $P is the main stream
 S @("$ZINTERRUPT=""I $$JOBEXAM^VPRJREQ($ZPOSITION)""")
 X "U $P:(nowrap:nodelimiter:ioerror=""ETSOCK"")"
 S %="",@("%=$ZTRNLNM(""REMOTE_HOST"")") S:$L(%) IO("IP")=%
 G CHILD
 ;
 ; Child Handling Process ---------------------------------
 ;
 ; The following variables exist during the course of the request
 ; HTTPREQ contains the HTTP request, with subscripts as follow --
 ; HTTPREQ("method") contains GET, POST, PUT, HEAD, or DELETE
 ; HTTPREQ("path") contains the path of the request (part from server to ?)
 ; HTTPREQ("query") contains any query params (part after ?)
 ; HTTPREQ("header",name) contains a node for each header value
 ; HTTPREQ("body",n) contains as an array the body of the request
 ; HTTPREQ("location") stashes the location value for PUT, POST
 ; HTTPREQ("store") stashes the type of store (vpr or data)
 ;
 ; HTTPRSP contains the HTTP response (or name of global with the response)
 ; HTTPLOG indicates the logging level for this process
 ; HTTPERR non-zero if there is an error state
 ;
CHILD ; handle HTTP requests on this connection
 N %WTCP S %WTCP=$GET(TCPIO,$PRINCIPAL) ; TCP Device
 N %WOS S %WOS=$S(+$SY=47:"GT.M",+$SY=50:"MV1",1:"CACHE") ; Get Mumps Virtual Machine
 S HTTPLOG=$G(^VPRHTTP(0,"logging"),0) ; HTTPLOG remains set throughout
 S HTTPLOG("DT")=+$H
 N $ET S $ET="G ETSOCK^VPRJREQ"
 ;
NEXT ; begin next request
 K HTTPREQ,HTTPRSP,HTTPERR
 K ^TMP($J),^TMP("HTTPERR",$J) ; TODO: change the namespace for the error global
 ;
WAIT ; wait for request on this connection
 I $E($G(^VPRHTTP(0,"listener")),1,4)="stop" C %WTCP Q
 X:%WOS="CACHE" "U %WTCP:(::""CT"")" ;VEN/SMH - Cache Only line; Terminators are $C(10,13)
 X:%WOS="GT.M" "U %WTCP:(delim=$C(13,10))" ; VEN/SMH - GT.M Delimiters
 R TCPX:10 I '$T G ETDC
 I '$L(TCPX) G ETDC
 ;
 ; -- got a request and have the first line
 D INCRLOG ; set unique request id
 I HTTPLOG D LOGRAW(TCPX),LOGHDR(TCPX)
 S HTTPREQ("method")=$P(TCPX," ")
 S HTTPREQ("path")=$P($P(TCPX," ",2),"?")
 S HTTPREQ("query")=$P($P(TCPX," ",2),"?",2,999)
 ; TODO: time out connection after N minutes of wait
 ; TODO: check format of TCPX and raise error if not correct
 I $E($P(TCPX," ",3),1,4)'="HTTP" G NEXT
 ;
 ; -- read the rest of the lines in the header
 F  S TCPX=$$RDCRLF() Q:'$L(TCPX)  D ADDHEAD(TCPX)
 ;
 ; -- Handle Contiuation Request - VEN/SMH
 I $G(HTTPREQ("header","expect"))="100-continue" D LOGCN W "HTTP/1.1 100 Continue",$C(13,10,13,10),!
 ;
 ; -- decide how to read body, if any
 X:%WOS="CACHE" "U %WTCP:(::""S"")" ; Stream mode
 X:%WOS="GT.M" "U %WTCP:(nodelim)" ; VEN/SMH - GT.M Delimiters
 I $$LOW^VPRJRUT($G(HTTPREQ("header","transfer-encoding")))="chunked" D
 . D RDCHNKS ; TODO: handle chunked input
 . I HTTPLOG>2 ; log array of chunks
 I $G(HTTPREQ("header","content-length"))>0 D
 . D RDLEN(HTTPREQ("header","content-length"),99)
 . I HTTPLOG>2 D LOGBODY
 ;
 ; -- build response (map path to routine & call, otherwise 404)   
 S $ETRAP="G ETCODE^VPRJREQ"
 S HTTPERR=0
 D RESPOND^VPRJRSP
 S $ETRAP="G ETSOCK^VPRJREQ"
 ; TODO: restore HTTPLOG if necessary
 ;
 ; -- write out the response (error if HTTPERR>0)
 X:%WOS="CACHE" "U %WTCP:(::""S"")" ; Stream mode
 X:%WOS="GT.M" "U %WTCP:(nodelim)" ; VEN/SMH - GT.M Delimiters
 I $G(HTTPERR) D RSPERROR^VPRJRSP ; switch to error response
 I HTTPLOG>2 D LOGRSP
 D SENDATA^VPRJRSP
 ;
 ; -- exit on Connection: Close
 I $$LOW^VPRJRUT($G(HTTPREQ("header","connection")))="close" D  HALT
 . K ^TMP($J),^TMP("HTTPERR",$J)
 . C %WTCP
 ;
 ; -- otherwise get ready for the next request
 I %WOS="GT.M"&$G(HTTPLOG) ZGOTO 0:NEXT^VPRJREQ ; unlink all routines; only for debug mode
 G NEXT
 ;
RDCRLF() ; read a header line
 ; fixes a problem where the read would terminate before CRLF
 ; (on a packet boundary or when 1024 characters had been read)
 N X,LINE,RETRY
 S LINE=""
 F RETRY=1:1 R X:1 D:HTTPLOG LOGRAW(X) S LINE=LINE_X Q:$A($ZB)=13  Q:RETRY>10
 Q LINE
 ;
RDCHNKS ; read body in chunks
 Q  ; still need to implement
 ;
RDLEN(REMAIN,TIMEOUT) ; read L bytes with timeout T
 N X,LINE,LENGTH
 S LINE=0
RDLOOP ;
 ; read until L bytes collected
 ; quit with what we have if read times out
 S LENGTH=REMAIN I LENGTH>4000 S LENGTH=4000
 R X#LENGTH:TIMEOUT
 I '$T D:HTTPLOG>1 LOGRAW("timeout:"_X) S LINE=LINE+1,HTTPREQ("body",LINE)=X Q
 I HTTPLOG>1 D LOGRAW(X)
 S REMAIN=REMAIN-$L(X),LINE=LINE+1,HTTPREQ("body",LINE)=X
 G:REMAIN RDLOOP
 Q
 ;
ADDHEAD(LINE) ; add header name and header value
 ; expects HTTPREQ to be defined
 D:HTTPLOG LOGHDR(LINE)
 N NAME,VALUE
 S NAME=$$LOW^VPRJRUT($$LTRIM^VPRJRUT($P(LINE,":")))
 S VALUE=$$LTRIM^VPRJRUT($P(LINE,":",2,99))
 I LINE'[":" S NAME="",VALUE=LINE
 I '$L(NAME) S NAME=$G(HTTPREQ("header")) ; grab the last name used
 I '$L(NAME) Q  ; no header name so just ignore this line
 I $D(HTTPREQ("header",NAME)) D
 . S HTTPREQ("header",NAME)=HTTPREQ("header",NAME)_","_VALUE
 E  D
 . S HTTPREQ("header",NAME)=VALUE,HTTPREQ("header")=NAME
 Q
 ;
ETSOCK ; error trap when handling socket (i.e., client closes connection)
 D LOGERR
 C %WTCP
 HALT  ; exit because connection has been closed
 ;
ETCODE ; error trap when calling out to routines
 S $ETRAP="G ETBAIL^VPRJREQ"
 I $TLEVEL TROLLBACK ; abandon any transactions
 L                   ; release any locks
 ; Set the error information and write it as the HTTP response.
 D LOGERR
 D SETERROR^VPRJRUT(501,"Log ID:"_HTTPLOG("ID")) ; sets HTTPERR
 D RSPERROR^VPRJRSP  ; switch to error response
 D SENDATA^VPRJRSP
 ; Leave $ECODE as non-null so that the error handling continues.
 ; This next line will 'unwind' the stack and got back to listening
 ; for the next HTTP request (goto NEXT).
 S $ETRAP="Q:$ESTACK&$QUIT 0 Q:$ESTACK  S $ECODE="""" G NEXT"
 Q
ETDC ; error trap for client disconnect ; not a true M trap
 D LOGDC
 K ^TMP($J),^TMP("HTTPERR",$J)
 C $P  
 HALT ; Stop process 
 ;
ETBAIL ; error trap of error traps
 U %WTCP
 W "HTTP/1.1 500 Internal Server Error",$C(13,10),$C(13,10),!
 K ^TMP($J),^TMP("HTTPERR",$J)
 C %WTCP
 HALT  ; exit because we can't recover
 ;
INCRLOG ; get unique log id for each request
 N DT,ID
 S DT=HTTPLOG("DT")
 L +^VPRHTTP("log",DT):2 E  S HTTPLOG("ID")=99999 Q  ; get unique logging session
 S ID=$G(^VPRHTTP("log",DT),0)+1
 S ^VPRHTTP("log",DT)=ID
 L -^VPRHTTP("log",DT)
 S HTTPLOG("ID")=ID
 Q:'HTTPLOG
 S ^VPRHTTP("log",DT,$J,ID)=$$HTE^VPRJRUT($H)_"  $J:"_$J_"  $P:"_%WTCP_"  $STACK:"_$STACK
 Q
LOGRAW(X) ; log raw lines read in
 N DT,ID,LN
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 S LN=$G(^VPRHTTP("log",DT,$J,ID,"raw"),0)+1
 S ^VPRHTTP("log",DT,$J,ID,"raw")=LN
 S ^VPRHTTP("log",DT,$J,ID,"raw",LN)=X
 S ^VPRHTTP("log",DT,$J,ID,"raw",LN,"ZB")=$A($ZB)
 Q
LOGHDR(X) ; log header lines read in
 N DT,ID,LN
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 S LN=$G(^VPRHTTP("log",DT,$J,ID,"req","header"),0)+1
 S ^VPRHTTP("log",DT,$J,ID,"req","header")=LN
 S ^VPRHTTP("log",DT,$J,ID,"req","header",LN)=X
 Q
LOGBODY ; log the request body
 Q:'$D(HTTPREQ("body"))
 N DT,ID
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 M ^VPRHTTP("log",DT,$J,ID,"req","body")=HTTPREQ("body")
 Q
LOGRSP ; log the response before sending
 Q:'$L($G(HTTPRSP))  ; Q:'$D(@HTTPRSP) VEN/SMH - Response may be scalar
 N DT,ID
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 I $E(HTTPRSP)="^" M ^VPRHTTP("log",DT,$J,ID,"response")=@HTTPRSP
 E  M ^VPRHTTP("log",DT,$J,ID,"response")=HTTPRSP
 Q
LOGCN ; log continue
 N DT,ID
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 S ^VPRHTTP("log",DT,$J,ID,"continue")="HTTP/1.1 100 Continue"
 QUIT
LOGDC ; log client disconnection; VEN/SMH
 N DT,ID
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 S ^VPRHTTP("log",DT,$J,ID,"disconnect")=$$HTE^VPRJRUT($H)
 QUIT
 ;
LOGERR ; log error information
 N %D,%I
 S %D=HTTPLOG("DT"),%I=HTTPLOG("ID")
 N ISGTM S ISGTM=$P($SYSTEM,",")=47
 S ^VPRHTTP("log",%D,$J,%I,"error")=$S(ISGTM:$ZSTATUS,1:$ZERROR_"  ($ECODE:"_$ECODE_")")
 N %LVL,%TOP,%N
 S %TOP=$STACK(-1),%N=0
 F %LVL=0:1:%TOP S %N=%N+1,^VPRHTTP("log",%D,$J,%I,"error","stack",%N)=$STACK(%LVL,"PLACE")_":"_$STACK(%LVL,"MCODE")
 N %X,%Y
 S %X="^VPRHTTP(""log"",%D,$J,%I,""error"",""symbols"","
 ; Works on GT.M and Cache to capture ST.
 S %Y="%" F  M:$D(@%Y) @(%X_"%Y)="_%Y) S %Y=$O(@%Y) Q:%Y=""
 Q
 ;
SIGNON ; TODO: VISTA SIGN-ON
 ;
SIGNOFF ; TODO: VISTA SIGN-OFF
 ;
 ; Deprecated -- use VPRJ
 ;
STOP ; tell the listener to stop running
 S ^VPRHTTP(0,"listener")="stopped"
 Q

VPRJRSP
VPRJRSP ;SLC/KCM -- Handle HTTP Response;2013-10-18  6:37 AM
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; -- prepare and send RESPONSE
 ;
RESPOND ; find entry point to handle request and call it
 ; expects HTTPREQ, HTTPRSP is used to return the response
 ;
 ; TODO: check cache of HEAD requests first and return that if there?
 K ^TMP($J)
 N ROUTINE,LOCATION,HTTPARGS,HTTPBODY
 I HTTPREQ("path")="/",HTTPREQ("method")="GET" D EN^%WHOME(.HTTPRSP) QUIT  ; Home page requested.
 D MATCH(.ROUTINE,.HTTPARGS) I $G(HTTPERR) QUIT  ; Resolve the URL and authenticate if necessary
 D QSPLIT(.HTTPARGS) I $G(HTTPERR) QUIT          ; Split the query string
 S HTTPREQ("paging")=$G(HTTPARGS("start"),0)_":"_$G(HTTPARGS("limit"),999999)
 S HTTPREQ("store")=$S($$LOW^VPRJRUT($E(HTTPREQ("path"),2,4))="vpr":"vpr",1:"data")
 I "PUT,POST"[HTTPREQ("method") D
 . N BODY
 . M BODY=HTTPREQ("body") K HTTPREQ("body")
 . X "S LOCATION=$$"_ROUTINE_"(.HTTPARGS,.BODY,.HTTPRSP)" ; VEN/SMH - Modified -- added HTTPRSP per http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.2
 . I $L(LOCATION) S HTTPREQ("location")=$S($D(HTTPREQ("header","host")):"https://"_HTTPREQ("header","host")_LOCATION,1:LOCATION)
 E  D @(ROUTINE_"(.HTTPRSP,.HTTPARGS)")
 Q
QSPLIT(QUERY) ; parses and decodes query fragment into array
 ; expects HTTPREQ to contain "query" node
 ; .QUERY will contain query parameters as subscripts: QUERY("name")=value
 N I,X,NAME,VALUE
 F I=1:1:$L(HTTPREQ("query"),"&") D
 . S X=$$URLDEC^VPRJRUT($P(HTTPREQ("query"),"&",I))
 . S NAME=$P(X,"="),VALUE=$P(X,"=",2,999)
 . I $L(NAME) S QUERY($$LOW^VPRJRUT(NAME))=VALUE
 Q
MATCH(ROUTINE,ARGS) ; evaluate paths in sequence until match found (else 404)
 ; Also does authentication and authorization
 ; TODO: this needs some work so that it will accomodate patterns shorter than the path
 ; expects HTTPREQ to contain "path" and "method" nodes
 ; ROUTINE contains the TAG^ROUTINE to execute for this path, otherwise empty
 ; .ARGS will contain an array of resolved path arguments
 ;
 N AUTHNODE ; Authentication and Authorization node
 ;
 S ROUTINE=""  ; Default. Routine not found. Error 404.
 ;
 ; If we have the %W file for mapping...
 IF $D(^%W(17.6001)) DO MATCHF(.ROUTINE,.ARGS,.AUTHNODE) 
 ;
 ; Using built-in table if routine is still empty.
 I ROUTINE="" DO MATCHR(.ROUTINE,.ARGS)
 ;
 ; Okay. Do we have a routine to execute?
 I ROUTINE="" D SETERROR^VPRJRUT(404,"Not Found") QUIT
 ;
 I +$G(AUTHNODE) D  ; Web Service has authorization node
 . ;
 . ; If there is no File 200, forget the whole thing. Pretend it didn't happen.
 . I '$D(^VA(200)) QUIT
 . ;
 . ; First, user must authenticate
 . S HTTPRSP("auth")="Basic realm="""_HTTPREQ("header","host")_"""" ; Send Authentication Header
 . N AUTHEN S AUTHEN=$$AUTHEN($G(HTTPREQ("header","authorization"))) ; Try to authenticate
 . I 'AUTHEN D SETERROR^VPRJRUT(401) QUIT  ; Unauthoirzed
 . ;
 . ; DEBUG.ASSERT that DUZ is greater than 0
 . I $G(DUZ)'>0 S $EC=",U-NO-DUZ,"
 . ;
 . ; Then user must have security key
 . N KEY S KEY=$P(AUTHNODE,"^",2)    ; Get Key pointer
 . I KEY S KEY=$P($G(^DIC(19.1,KEY,0)),"^") ; Get Key name from Security Key file
 . I $L(KEY),'$D(^XUSEC(KEY,DUZ)) D SETERROR^VPRJRUT(405,"Missing security key "_KEY) QUIT  ; Method not allowed
 . K KEY
 . ;
 . ; And not have reverse security key
 . N RKEY S RKEY=$P(AUTHNODE,"^",3)  ; Get Key pointer
 . I RKEY S RKEY=$P($G(^DIC(19.1,RKEY,0)),"^") ; Get Reverse Key name from Security Key file
 . I $L(RKEY),$D(^XUSEC(RKEY,DUZ)) D SETERROR^VPRJRUT(405,"Holding exclusive key "_RKEY) QUIT  ; Method not allowed
 . K RKEY
 . ;
 . ; And have access to the menu option indicated
 . N OPTION S OPTION=$P(AUTHNODE,"^",4)  ; Get Option pointer
 . I OPTION N OPTIONNM S OPTIONNM=$P($G(^DIC(19,OPTION,0)),"^") ; Get Option name from Option file
 . I OPTION,$L($T(ACCESS^XQCHK)),'$$ACCESS^XQCHK(DUZ,OPTION) D SETERROR^VPRJRUT(405,"No access to option "_OPTIONNM)  ; Method not allowed
 . K OPTION,OPTIONNM
 QUIT
 ;
 ;
MATCHF(ROUTINE,ARGS,AUTHNODE) ; Match against a file...
 ; ^%W(17.6001,"B","GET","xml"
 N PATH S PATH=HTTPREQ("path")
 S:$E(PATH)="/" PATH=$E(PATH,2,$L(PATH))
 ;
 N DONE S DONE=0
 N PATH1 S PATH1=$$URLDEC^VPRJRUT($P(PATH,"/",1),1) ; get first / piece of path; and decode.
 N PATTERN S PATTERN=PATH1  ; looper variable; start at first piece of path.
 I $D(^%W(17.6001,"B",HTTPREQ("method"),PATTERN)) D  ; if path isn't just a simple full path that already exists
 . S ROUTINE=$O(^%W(17.6001,"B",HTTPREQ("method"),PATTERN,""))
 E  D
 . ; Loop through patterns. Start with first piece of path. quit if $order took us off the deep end.
 . F  S PATTERN=$O(^%W(17.6001,"B",HTTPREQ("method"),PATTERN)) Q:PATTERN=""  Q:PATH1'=$E(PATTERN,1,$L(PATH1))  D  Q:DONE
 . . ;
 . . ; TODO: only matches 1st piece then *. Second piece can be different.
 . . N I F I=2:1:$L(PATTERN,"/") D
 . . . N PATTSEG S PATTSEG=$$URLDEC^VPRJRUT($P(PATTERN,"/",I),1) ; pattern Segment url-decoded
 . . . I PATTSEG="*" S ARGS("*")=$P(PATH,"/",I,999) QUIT
 . . ;
 . . I $D(ARGS("*")) S DONE=1 QUIT  ; We are done if we found the *
 . . ;
 . . I $L(PATTERN,"/")'=$L(PATH,"/") QUIT  ; not the same number of pieces; quit.
 . . K ARGS
 . . N FAIL S FAIL=0
 . . N I F I=2:1:$L(PATH,"/") D  Q:FAIL  ; we have matched the first piece; now, do every piece after that.
 . . . N PATHSEG S PATHSEG=$$URLDEC^VPRJRUT($P(PATH,"/",I),1)  ; Path Segment url-decoded
 . . . N PATTSEG S PATTSEG=$$URLDEC^VPRJRUT($P(PATTERN,"/",I),1) ; pattern Segment url-decoded
 . . . I $E(PATTSEG)'="{" S FAIL=($$LOW^VPRJRUT(PATHSEG)'=$$LOW^VPRJRUT(PATTSEG)) Q  ; if not mumps pattern, just string equality
 . . . S PATTSEG=$E(PATTSEG,2,$L(PATTSEG)-1) ; else, extract pattern by getting rid of curly braces
 . . . N ARGUMENT,TEXT S ARGUMENT=$P(PATTSEG,"?"),TEST=$P(PATTSEG,"?",2) ; get pattern match
 . . . I $L(TEST) S FAIL=(PATHSEG'?@TEST) Q:FAIL  ; run pattern match
 . . . S ARGS(ARGUMENT)=PATHSEG  ; if pattern matches, put into arguments hopper.
 . . ;
 . . Q:FAIL  ; last loop failed to find a match
 . . ;
 . . ; At this point, none of the stuff failed. We can tell the initial loop that we are done.
 . . S DONE=1
 Q:PATH1'=$E(PATTERN,1,$L(PATH1))
 S ROUTINE=$O(^%W(17.6001,"B",HTTPREQ("method"),PATTERN,""))
 N IEN S IEN=$O(^%W(17.6001,"B",HTTPREQ("method"),PATTERN,ROUTINE,""))
 S AUTHNODE=$G(^%W(17.6001,IEN,"AUTH"))
 QUIT
 ;
 ;
 ;
MATCHR(ROUTINE,ARGS) ; Match against this routine
 N PATH S PATH=HTTPREQ("path")
 S:$E(PATH)="/" PATH=$E(PATH,2,$L(PATH))
 N SEQ,METHOD
 N DONE S DONE=0
 F SEQ=1:1 S PATTERN=$P($T(URLMAP+SEQ),";;",2,99) Q:PATTERN="zzzzz"  D  Q:DONE
 . K ARGS
 . S ROUTINE=$P(PATTERN," ",3),METHOD=$P(PATTERN," "),PATTERN=$P(PATTERN," ",2),FAIL=0
 . I $L(PATTERN,"/")'=$L(PATH,"/") S ROUTINE="" Q  ; must have same number segments
 . F I=1:1:$L(PATH,"/") D  Q:FAIL
 . . S PATHSEG=$$URLDEC^VPRJRUT($P(PATH,"/",I),1)
 . . S PATTSEG=$$URLDEC^VPRJRUT($P(PATTERN,"/",I),1)
 . . I $E(PATTSEG)'="{" S FAIL=($$LOW^VPRJRUT(PATHSEG)'=$$LOW^VPRJRUT(PATTSEG)) Q
 . . S PATTSEG=$E(PATTSEG,2,$L(PATTSEG)-1) ; get rid of curly braces
 . . S ARGUMENT=$P(PATTSEG,"?"),TEST=$P(PATTSEG,"?",2)
 . . I $L(TEST) S FAIL=(PATHSEG'?@TEST) Q:FAIL
 . . S ARGS(ARGUMENT)=PATHSEG
 . I 'FAIL I METHOD'=HTTPREQ("method") S FAIL=1
 . S:FAIL ROUTINE="" S:'FAIL DONE=1
 QUIT
 ;
 ;
 ;
SENDATA ; write out the data as an HTTP response
 ; expects HTTPERR to contain the HTTP error code, if any
 ; RSPTYPE=1  local variable
 ; RSPTYPE=2  data in ^TMP($J)
 ; RSPTYPE=3  pageable data in ^TMP($J,"data") or ^VPRTMP(hash,"data")
 ;
 N %WBUFF S %WBUFF="" ; Write Buffer
 ;
 N SIZE,RSPTYPE,PREAMBLE,START,LIMIT
 S RSPTYPE=$S($E($G(HTTPRSP))'="^":1,$D(HTTPRSP("pageable")):3,1:2)
 I RSPTYPE=1 S SIZE=$$VARSIZE^VPRJRUT(.HTTPRSP)
 I RSPTYPE=2 S SIZE=$$REFSIZE^VPRJRUT(.HTTPRSP)
 I RSPTYPE=3 D
 . S START=$P(HTTPREQ("paging"),":"),LIMIT=$P(HTTPREQ("paging"),":",2)
 . D PAGE^VPRJRUT(.HTTPRSP,START,LIMIT,.SIZE,.PREAMBLE)
 ;
 ; TODO: Handle HEAD requests differently
 ;       (put HTTPRSP in ^XTMP and return appropriate header)
 ; TODO: Handle 201 responses differently (change simple OK to created)
 ;
 D W($$RSPLINE()_$C(13,10)) ; Status Line (200, 404, etc)
 D W("Date: "_$$GMT^VPRJRUT_$C(13,10)) ; RFC 1123 date
 I $D(HTTPREQ("location")) D W("Location: "_HTTPREQ("location")_$C(13,10))  ; ?? Request location; TODO: Check this. Should be Response.
 I $D(HTTPRSP("auth")) D W("WWW-Authenticate: "_HTTPRSP("auth")_$C(13,10)) K HTTPRSP("auth") ; Authentication
 I $D(HTTPRSP("mime")) D  ; Stack $TEST for the ELSE below
 . D W("Content-Type: "_HTTPRSP("mime")_$C(13,10)) K HTTPRSP("mime") ; Mime-type
 E  D W("Content-Type: application/json; charset=utf-8"_$C(13,10))
 ;
 ; I +$SY=47,$G(HTTPREQ("header","accept-encoding"))["gzip" D GZIP QUIT  ; If on GT.M, and we can zip, let's do that!
 ;
 D W("Content-Length: "_SIZE_$C(13,10)_$C(13,10))
 I 'SIZE D FLUSH Q  ; flush buffer and quit if empty
 ;
 N I,J
 I RSPTYPE=1 D            ; write out local variable
 . I $D(HTTPRSP)#2 D W(HTTPRSP)
 . I $D(HTTPRSP)>1 S I=0 F  S I=$O(HTTPRSP(I)) Q:'I  D W(HTTPRSP(I))
 I RSPTYPE=2 D            ; write out global using indirection
 . I $D(@HTTPRSP)#2 D W(@HTTPRSP)
 . I $D(@HTTPRSP)>1 S I=0 F  S I=$O(@HTTPRSP@(I)) Q:'I  D W(@HTTPRSP@(I))
 I RSPTYPE=3 D            ; write out pageable records
 . W PREAMBLE
 . F I=START:1:(START+LIMIT-1) Q:'$D(@HTTPRSP@($J,I))  D
 . . I I>START D W(",") ; separate items with a comma
 . . S J="" F  S J=$O(@HTTPRSP@($J,I,J)) Q:'J  D W(@HTTPRSP@($J,I,J))
 . D W("]}}")
 . K @HTTPRSP@($J)
 D FLUSH ; flush buffer
 ; W $C(13,10),!  ; flush buffer ; ****VEN/SMH NOT INCLUDED IN THE SIZE!!!
 I RSPTYPE=3,($E(HTTPRSP,1,4)="^TMP") D UPDCACHE
 Q
W(DATA) ; EP to write data
 ; ZEXCEPT: %WBUFF - Buffer in Symbol Table
 S %WBUFF=%WBUFF_DATA
 I $L(%WBUFF)>32000 D FLUSH
 QUIT
 ;
FLUSH ; EP to flush written data
 ; ZEXCEPT: %WBUFF - Buffer in Symbol Table
 W %WBUFF,!
 S %WBUFF=""
 QUIT
 ;
GZIP ; EP to write gzipped content -- unstable right now...
 ;
 ; Nothing to write?
 I 'SIZE D  QUIT  ; nothing to write!
 . W "Content-Length: 0"_$C(13,10,13,10)
 . W ! ; flush buffer
 ;
 ; zip away - Open gzip and write to it, then read back the zipped file.
 N OLDIO S OLDIO=$IO
 ; NB: Must have wrap,fixed,chset="M" for GT.M to read the data back as binary.
 O "D":(shell="/bin/sh":command="gzip -f":parse:wrap:fixed:chset="M")::"pipe" 
 U "D"
 ;
 ; Write out data
 N ZIPPED,C S C=1
 N I,J
 I RSPTYPE=1 D            ; write out local variable
 . I $D(HTTPRSP)#2 W HTTPRSP ; R ZIPPED(C):0 I  S C=C+1
 . I $D(HTTPRSP)>1 S I=0 F  S I=$O(HTTPRSP(I)) Q:'I  W HTTPRSP(I) R ZIPPED(C)#32767:0 S C=C+1
 I RSPTYPE=2 D            ; write out global using indirection
 . I $D(@HTTPRSP)#2 W @HTTPRSP ; R ZIPPED(C):0 I  S C=C+1
 . I $D(@HTTPRSP)>1 S I=0 F  S I=$O(@HTTPRSP@(I)) Q:'I  W @HTTPRSP@(I) ; R ZIPPED(C):0 I  S C=C+1
 I RSPTYPE=3 D            ; write out pageable records
 . W PREAMBLE
 . F I=START:1:(START+LIMIT-1) Q:'$D(@HTTPRSP@($J,I))  D
 . . I I>START W "," ; R ZIPPED(C):0 I  S C=C+1 ; separate items with a comma
 . . S J="" F  S J=$O(@HTTPRSP@($J,I,J)) Q:'J  W @HTTPRSP@($J,I,J) ; R ZIPPED(C):0 I  S C=C+1
 . W "]}}" ; R ZIPPED(C):0 I  S C=C+1
 . K @HTTPRSP@($J)
 ;
 ZSHOW "V":^KBANRPC1
 ; Tell gzip we are done.
 W /EOF
 ;
 ; Read back
 F  R ZIPPED(C)#32767 Q:$ZEOF  S C=C+1
 ;
 ; Close
 U OLDIO C "D"
 ; 
 ; Calculate new size (reset SIZE first)
 S SIZE=0 
 N I F I=0:0 S I=$O(ZIPPED(I)) Q:'I  S SIZE=SIZE+$L(ZIPPED(I))
 ;
 ; Write out the content headings for gzipped file.
 W "Content-Encoding: gzip"_$C(13,10)
 W "Content-Length: "_SIZE_$C(13,10)_$C(13,10)
 N I F I=0:0 S I=$O(ZIPPED(I)) Q:'I  W ZIPPED(I)
 W !
 ;
 ZSHOW "V":^KBANRPC2
 ; House keeping.
 I RSPTYPE=3,($E(HTTPRSP,1,4)="^TMP") D UPDCACHE
 QUIT
 ;
UPDCACHE ; update the cache for this query
 I HTTPREQ("store")="data" G UPD4DATA
UPD4VPR ;
 N PID,INDEX,HASH,HASHTS,MTHD
 S PID=$G(^TMP($J,"pid")),INDEX=$G(^TMP($J,"index"))
 S HASH=$G(^TMP($J,"hash")),HASHTS=$G(^TMP($J,"timestamp"))
 Q:'$L(PID)  Q:'$L(INDEX)  Q:'$L(HASH)
 ;
 S MTHD=$G(^VPRMETA("index",INDEX,"common","method"))
 L +^VPRTMP(HASH):1  E  Q
 I $G(^VPRPTI(PID,MTHD,INDEX))=HASHTS D
 . K ^VPRTMP(HASH)
 . M ^VPRTMP(HASH)=^TMP($J)
 . S ^VPRTMP(HASH,"created")=$H
 . S ^VPRTMP("PID",PID,HASH)=""
 L -^VPRTMP(HASH)
 Q
UPD4DATA ;
 N INDEX,HASH,HASHTS,MTHD
 S INDEX=$G(^TMP($J,"index"))
 S HASH=$G(^TMP($J,"hash")),HASHTS=$G(^TMP($J,"timestamp"))
 Q:'$L(INDEX)  Q:'$L(HASH)
 ;
 S MTHD=$G(^VPRJMETA("index",INDEX,"common","method"))
 L +^VPRTMP(HASH):1  E  Q
 I $G(^VPRJDX(MTHD,INDEX))=HASHTS D
 . K ^VPRTMP(HASH)
 . M ^VPRTMP(HASH)=^TMP($J)
 . S ^VPRTMP(HASH,"created")=$H
 L -^VPRTMP(HASH)
 Q
RSPERROR ; set response to be an error response
 D ENCODE^VPRJSON("^TMP(""HTTPERR"",$J,1)","^TMP(""HTTPERR"",$J,""JSON"")")
 S HTTPRSP="^TMP(""HTTPERR"",$J,""JSON"")"
 K HTTPRSP("pageable")
 Q
RSPLINE() ; writes out a response line based on HTTPERR
 ; VEN/SMH: TODO: There ought to be a simpler way to do this!!!
 I '$G(HTTPERR),'$D(HTTPREQ("location")) Q "HTTP/1.1 200 OK"
 I '$G(HTTPERR),$D(HTTPREQ("location")) Q "HTTP/1.1 201 Created"
 I $G(HTTPERR)=400 Q "HTTP/1.1 400 Bad Request"
 I $G(HTTPERR)=401 Q "HTTP/1.1 401 Unauthorized"
 I $G(HTTPERR)=404 Q "HTTP/1.1 404 Not Found"
 I $G(HTTPERR)=405 Q "HTTP/1.1 405 Method Not Allowed"
 Q "HTTP/1.1 500 Internal Server Error"
 ;
PING(RESULT,ARGS) ; writes out a ping response
 S RESULT="{""status"":"""_$J_" running""}"
 Q
XML(RESULT,ARGS) ; text XML
 S HTTPRSP("mime")="text/xml"
 S RESULT=$NA(^TMP($J))
 S ^TMP($J,1)="<?xml version=""1.0"" encoding=""UTF-8""?>"
 S ^TMP($J,2)="<note>"
 S ^TMP($J,3)="<to>Tovaniannnn</to>"
 S ^TMP($J,4)="<from>Jani</from>"
 S ^TMP($J,5)="<heading>Remindersss</heading>"
 S ^TMP($J,6)="<body>Don't forget me this weekend!</body>"
 S ^TMP($J,7)="</note>"
 QUIT
VPRMATCH(ROUTINE,ARGS) ; specific algorithm for matching URL's
 Q
URLMAP ; map URLs to entry points (HTTP methods handled within entry point)
 ;;POST vpr/{pid?1.N} PUTOBJ^VPRJPR
 ;;PUT vpr/{pid?1.N} PUTOBJ^VPRJPR
 ;;GET vpr/{pid?1.N}/index/{indexName} INDEX^VPRJPR
 ;;GET vpr/{pid?1.N}/index/{indexName}/{template} INDEX^VPRJPR
 ;;GET vpr/{pid?1.N}/count/{countName} COUNT^VPRJPR
 ;;GET vpr/{pid?1.N}/last/{indexName} LAST^VPRJPR
 ;;GET vpr/{pid?1.N}/last/{indexName}/{template} LAST^VPRJPR
 ;;GET vpr/{pid?1.N}/{uid?1"urn:".E} GETOBJ^VPRJPR
 ;;GET vpr/{pid?1.N}/{uid?1"urn:".E}/{template} GETOBJ^VPRJPR
 ;;GET vpr/{pid?1.N}/find/{collection} FIND^VPRJPR
 ;;GET vpr/{pid?1.N}/find/{collection}/{template} FIND^VPRJPR
 ;;GET vpr/{pid?1.N} GETPT^VPRJPR
 ;;GET vpr/uid/{uid?1"urn:".E} GETUID^VPRJPR
 ;;GET vpr/uid/{uid?1"urn:".E}/{template} GETUID^VPRJPR
 ;;POST vpr PUTPT^VPRJPR
 ;;PUT vpr PUTPT^VPRJPR
 ;;GET vpr/all/count/{countName} ALLCOUNT^VPRJPR
 ;;GET vpr/all/index/{indexName} ALLINDEX^VPRJPR
 ;;GET vpr/all/index/{indexName}/{template} ALLINDEX^VPRJPR
 ;;GET vpr/all/find/{collection} ALLFIND^VPRJPR
 ;;GET vpr/all/find/{collection}/{template} ALLFIND^VPRJPR
 ;;GET vpr/pid/{icndfn} PID^VPRJPR
 ;;DELETE vpr/{pid?1.N}/{uid?1"urn:".E} DELUID^VPRJPR
 ;;DELETE vpr/uid/{uid?1"urn:".E} DELUID^VPRJPR
 ;;DELETE vpr/{pid?1.N} DELPT^VPRJPR
 ;;DELETE vpr DELALL^VPRJPR
 ;;DELETE vpr/{pid?1.N}/collection/{collectionName} DELCOLL^VPRJPR
 ;;DELETE vpr/all/collection/{collectionName} ALLDELC^VPRJPR
 ;;POST data PUTOBJ^VPRJDR
 ;;PUT data PUTOBJ^VPRJDR
 ;;PUT data/{collectionName} NEWOBJ^VPRJDR
 ;;POST data/{collectionName} NEWOBJ^VPRJDR
 ;;GET data/{uid?1"urn:".E} GETOBJ^VPRJDR
 ;;GET data/index/{indexName} INDEX^VPRJDR
 ;;GET data/last/{indexName} LAST^VPRJDR
 ;;GET data/count/{countName} COUNT^VPRJDR
 ;;GET data/find/{collection} FIND^VPRJDR
 ;;GET data/find/{collection}/{template} FIND^VPRJDR
 ;;DELETE data/{uid?1"urn:".E} DELUID^VPRJDR
 ;;DELETE data/collection/{collectionName} DELCTN^VPRJDR
 ;;DELETE data DELALL^VPRJDR
 ;;GET ping PING^VPRJRSP
 ;;zzzzz
 Q
AUTHEN(HTTPAUTH) ; Authenticate User against VISTA from HTTP Authorization Header
 ;
 ; We only support Basic authentication right now
 N P1,P2 S P1=$P(HTTPAUTH," "),P2=$P(HTTPAUTH," ",2)
 I $$UP^VPRJRUT(P1)'="BASIC" Q 0 ; We don't support that authentication
 ;
 ; Decode Base64 encoded un:pwd
 N ACVC S ACVC=$$DECODE64^VPRJRUT(P2)
 S ACVC=$TR(ACVC,":",";") ; switch the : so that it's now ac;vc
 ; TODO: Check if there is more than one colon in the ACVC
 ;
 ; Sign-on
 N IO S IO=$P
 D SETUP^XUSRB() ; Only partition set-up; No single sign-on or CAPRI
 N RTN D VALIDAV^XUSRB(.RTN,$$ENCRYP^XUSRB1(ACVC)) ; sign-on call
 I RTN(0)>0,'RTN(2) Q 1 ; Sign on successful!
 I RTN(0)=0,RTN(2) Q 0  ; Verify Code must be changed NOW!
 I $L(RTN(3)) Q 0  ; Error Message
 ;
 ; TODO: Division Selection
 QUIT 0

VPRJRUT
VPRJRUT ;SLC/KCM -- Utilities for HTTP communications ;2013-05-07  12:29 AM
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; Various mods to support GT.M. See diff with original for full listing.
 ;
UP(X) Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
LOW(X) Q $TR(X,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
 ;
LTRIM(%X) ; Trim whitespace from left side of string
 ; derived from XLFSTR, but also removes tabs
 N %L,%R
 S %L=1,%R=$L(%X)
 F %L=1:1:$L(%X) Q:$A($E(%X,%L))>32
 Q $E(%X,%L,%R)
 ;
URLENC(X) ; Encode a string for use in a URL
 ; Q $ZCONVERT(X,"O","URL")  ; uncomment for fastest performance on Cache
 ; =, &, %, +, non-printable 
 ; {, } added JC 7-24-2012
 N I,Y,Z,LAST
     S Y=$P(X,"%") F I=2:1:$L(X,"%") S Y=Y_"%25"_$P(X,"%",I)
 S X=Y,Y=$P(X,"&") F I=2:1:$L(X,"&") S Y=Y_"%26"_$P(X,"&",I)
 S X=Y,Y=$P(X,"=") F I=2:1:$L(X,"=") S Y=Y_"%3D"_$P(X,"=",I)
 S X=Y,Y=$P(X,"+") F I=2:1:$L(X,"+") S Y=Y_"%2B"_$P(X,"+",I)
 S X=Y,Y=$P(X,"{") F I=2:1:$L(X,"{") S Y=Y_"%7B"_$P(X,"{",I)
 S X=Y,Y=$P(X,"}") F I=2:1:$L(X,"}") S Y=Y_"%7D"_$P(X,"}",I)
 S Y=$TR(Y," ","+")
 S Z="",LAST=1
 F I=1:1:$L(Y) I $A(Y,I)<32 D
 . S CODE=$$DEC2HEX($A(Y,I)),CODE=$TR($J(CODE,2)," ","0")
 . S Z=Z_$E(Y,LAST,I-1)_"%"_CODE,LAST=I+1
 S Z=Z_$E(Y,LAST,$L(Y))
 Q Z
 ;
URLDEC(X,PATH) ; Decode a URL-encoded string
 ; Q $ZCONVERT(X,"I","URL")  ; uncomment for fastest performance on Cache
 ;
 N I,OUT,FRAG,ASC
 S:'$G(PATH) X=$TR(X,"+"," ") ; don't convert '+' in path fragment
 F I=1:1:$L(X,"%") D
 . I I=1 S OUT=$P(X,"%") Q
 . S FRAG=$P(X,"%",I),ASC=$E(FRAG,1,2),FRAG=$E(FRAG,3,$L(FRAG))
 . I $L(ASC) S OUT=OUT_$C($$HEX2DEC(ASC))
 . S OUT=OUT_FRAG
 Q OUT
 ;
REFSIZE(ROOT) ; return the size of glvn passed in ROOT
 Q:'$D(ROOT) 0 Q:'$L(ROOT) 0
 N SIZE,I
 S SIZE=0
 I $D(@ROOT)#2 S SIZE=$L(@ROOT)
 I $D(@ROOT)>1 S I=0 F  S I=$O(@ROOT@(I)) Q:'I  S SIZE=SIZE+$L(@ROOT@(I))
 Q SIZE
 ;
VARSIZE(V) ; return the size of a variable
 Q:'$D(V) 0
 N SIZE,I
 S SIZE=0
 I $D(V)#2 S SIZE=$L(V)
 I $D(V)>1 S I="" F  S I=$O(V(I)) Q:'I  S SIZE=SIZE+$L(V(I))
 Q SIZE
 ;
PAGE(ROOT,START,LIMIT,SIZE,PREAMBLE) ; create the size and preamble for a page of data
 Q:'$D(ROOT) 0 Q:'$L(ROOT) 0
 N I,J,KEY,KINST,COUNT,TEMPLATE,PID
 K @ROOT@($J)
 S SIZE=0,COUNT=0,TEMPLATE=$G(@ROOT@("template"),0),PID=$G(@ROOT@("pid"))
 F I=START:1:(START+LIMIT-1) Q:'$D(@ROOT@("data",I))  S COUNT=COUNT+1 D
 . S KEY="" F  S KEY=$O(@ROOT@("data",I,KEY)) Q:KEY=""  D
 . . S KINST="" F  S KINST=$O(@ROOT@("data",I,KEY,KINST)) Q:KINST=""  D
 . . . S PID=^(KINST)  ; null if non-pt data
 . . . D TMPLT(ROOT,TEMPLATE,I,KEY,KINST,PID)
 . . . S J="" F  S J=$O(@ROOT@($J,I,J)) Q:'J  S SIZE=SIZE+$L(@ROOT@($J,I,J))
 S PREAMBLE=$$BLDHEAD(@ROOT@("total"),COUNT,START,LIMIT)
 ; add 3 for "]}}", add COUNT-1 for commas
 S SIZE=SIZE+$L(PREAMBLE)+3+COUNT-$S('COUNT:0,1:1)
 Q
TMPLT(ROOT,TEMPLATE,ITEM,KEY,KINST,PID) ; set template
 I HTTPREQ("store")="data" G TLT4DATA
TLT4VPR ;
 ; called from PAGE
 I $G(TEMPLATE)="uid" S @ROOT@($J,ITEM,1)="{""uid"":"""_KEY_"""}" Q
 ; other template
 I $L(TEMPLATE),$D(^VPRPT("TEMPLATE",PID,KEY,TEMPLATE)) M @ROOT@($J,ITEM)=^(TEMPLATE) Q
 ; else full object
 M @ROOT@($J,ITEM)=^VPRPT("JSON",PID,KEY)
 Q
TLT4DATA ;
 ; called from PAGE
 I $G(TEMPLATE)="uid" S @ROOT@($J,ITEM,1)="{""uid"":"""_KEY_"""}" Q
 ; other template
 I $L(TEMPLATE),$D(^VPRJD("TEMPLATE",KEY,TEMPLATE)) M @ROOT@($J,ITEM)=^(TEMPLATE) Q
 ; else full object
 M @ROOT@($J,ITEM)=^VPRJD("JSON",KEY)
 Q
BLDHEAD(TOTAL,COUNT,START,LIMIT) ; Build the object header
 N X,UPDATED
 S UPDATED=$P($$FMTHL7^XLFDT($$NOW^XLFDT),"+")
 S X="{""apiVersion"":""1.0"",""data"":{""updated"":"_UPDATED_","
 S X=X_"""totalItems"":"_TOTAL_","
 S X=X_"""currentItemCount"":"_COUNT_","
 I LIMIT'=999999 D  ; only set thise if paging
 . S X=X_"""itemsPerPage"":"_LIMIT_","
 . S X=X_"""startIndex"":"_START_","
 . S X=X_"""pageIndex"":"_(START\LIMIT)_","
 . S X=X_"""totalPages"":"_(TOTAL\LIMIT+$S(TOTAL#LIMIT:1,1:0))_","
 S X=X_"""items"":["
 Q X
 ;
SETERROR(ERRCODE,MESSAGE) ; set error info into ^TMP("HTTPERR",$J)
 ; causes HTTPERR system variable to be set
 ; ERRCODE:  query errors are 100-199, update errors are 200-299, M errors are 500
 ; MESSAGE:  additional explanatory material
 N NEXTERR,ERRNAME,TOPMSG
 S HTTPERR=400,TOPMSG="Bad Request"
 ; query errors (100-199)
 I ERRCODE=101 S ERRNAME="Missing name of index"
 I ERRCODE=102 S ERRNAME="Invalid index name"
 I ERRCODE=103 S ERRNAME="Parameter error"
 I ERRCODE=104 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Bad key"
 I ERRCODE=105 S ERRNAME="Template required"
 I ERRCODE=106 S ERRNAME="Bad Filter Parameter"
 I ERRCODE=107 S ERRNAME="Unsupported Field Name"
 I ERRCODE=108 S ERRNAME="Bad Order Parameter"
 I ERRCODE=109 S ERRNAME="Operation not supported with this index"
 I ERRCODE=110 S ERRNAME="Order field unknown"
 I ERRCODE=111 S ERRNAME="Unrecognized parameter"
 I ERRCODE=112 S ERRNAME="Filter required"
 ; update errors (200-299)
 I ERRCODE=201 S ERRNAME="Unknown collection" ; unused?
 I ERRCODE=202 S ERRNAME="Unable to decode JSON"
 I ERRCODE=203 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Unable to determine patient"
 I ERRCODE=204 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Unable to determine collection" ; unused?
 I ERRCODE=205 S ERRNAME="Patient mismatch with object"
 I ERRCODE=207 S ERRNAME="Missing UID"
 I ERRCODE=209 S ERRNAME="Missing range or index" ; unused?
 I ERRCODE=210 S ERRNAME="Unknown UID format"
 I ERRCODE=211 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Missing patient identifiers"
 I ERRCODE=212 S ERRNAME="Mismatch of patient identifiers"
 I ERRCODE=213 S ERRNAME="Delete demographics only not allowed"
 I ERRCODE=214 S HTTPERR=404,ERRNAME="Patient ID not found in database"
 I ERRCODE=215 S ERRNAME="Missing collection name"
 I ERRCODE=216 S ERRNAME="Incomplete deletion of collection"
 ; HTTP errors
 I ERRCODE=400 S ERRNAME="Bad Request"
 I ERRCODE=401 S ERRNAME="Unauthorized" ; VEN/SMH
 I ERRCODE=404 S ERRNAME="Not Found"
 I ERRCODE=405 S ERRNAME="Method Not Allowed"
 ; system errors (500-599)
 I ERRCODE=501 S ERRNAME="M execution error"
 I ERRCODE=502 S ERRNAME="Unable to lock record"
 I '$L($G(ERRNAME)) S ERRNAME="Unknown error"
 ;
 I ERRCODE>500 S HTTPERR=500,TOPMSG="Internal Server Error"  ; M Server Error
 I ERRCODE<500,ERRCODE>400 S HTTPERR=ERRCODE,TOPMSG=ERRNAME  ; Other HTTP Errors 
 S NEXTERR=$G(^TMP("HTTPERR",$J,0),0)+1,^TMP("HTTPERR",$J,0)=NEXTERR
 S ^TMP("HTTPERR",$J,1,"apiVersion")="1.0"
 S ^TMP("HTTPERR",$J,1,"error","code")=HTTPERR
 S ^TMP("HTTPERR",$J,1,"error","message")=TOPMSG
 S ^TMP("HTTPERR",$J,1,"error","request")=$G(HTTPREQ("method"))_" "_$G(HTTPREQ("path"))_" "_$G(HTTPREQ("query"))
 S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"reason")=ERRCODE
 S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"message")=ERRNAME
 I $L($G(MESSAGE)) S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"domain")=MESSAGE
 Q
 ;
 ; Cache specific functions (selected one support GT.M too!)
 ;
LCLHOST() ; return TRUE if the peer connection is localhost
 I $E($I,1,5)'="|TCP|" Q 0
 N VER,ADDR
 S VER=$P($P($ZV,") ",2),"(")
 I VER<2011 S ADDR=$ZU(111,0),ADDR=$A(ADDR,1)_"."_$A(ADDR,2)_"."_$A(ADDR,3)_"."_$A(ADDR,4) I 1
 E  S ADDR=$SYSTEM.TCPDevice.PeerAddr(0)
 I ADDR="127.0.0.1" Q 1
 I ADDR="0:0:0:0:0:0:0:1" Q 1
 I ADDR="::1" Q 1
 Q 0
 ;
HASH(X) ; return CRC-32 of string contained in X
 Q $$CRC32(X) ; return the CRC-32 value; works on both Cache 
 ;
GMT() ; return HTTP date string (this is really using UTC instead of GMT)
 N TM,DAY
 I $$UP($ZV)["CACHE" D  Q $P(DAY," ")_", "_$ZDATETIME(TM,2)_" GMT"
 . S TM=$ZTIMESTAMP,DAY=$ZDATETIME(TM,11)
 ;
 N OUT
 I $$UP($ZV)["GT.M" D  Q OUT
 . N D S D="datetimepipe"
 . N OLDIO S OLDIO=$I
 . O D:(shell="/bin/sh":comm="date -u +'%a, %d %b %Y %H:%M:%S %Z'|sed 's/UTC/GMT/g'")::"pipe"
 . U D R OUT:1 
 . U OLDIO C D
 ;
 QUIT "UNIMPLEMENTED"
 ;
SYSID() ; return a likely unique system ID
 S X=$SYSTEM_":"_$G(^VPRHTTP("port"),9080) ; VPR web server port number
 QUIT $$CRC16HEX(X) ; return CRC-16 in hex
 ;
 ;
CRC16HEX(X) ; return CRC-16 in hexadecimal
 QUIT $$BASE($$CRC16(X),10,16) ; return CRC-16 in hex
 ;
 ;
CRC32HEX(X) ; return CRC-32 in hexadecimal
 QUIT $$BASE($$CRC32(X),10,16) ; return CRC-32 in hex
 ;
 ;
 ;
DEC2HEX(NUM) ; return a decimal number as hex
 Q $$BASE(NUM,10,16)
 ;Q $ZHEX(NUM)
 ;
HEX2DEC(HEX) ; return a hex number as decimal
 Q $$BASE(HEX,16,10)
 ;Q $ZHEX(HEX_"H")
 ;
WR4HTTP ; open file to save HTTP response
 I $$UP($ZV)["CACHE" O "VPRJT.TXT":"WNS"
 I $$UP($ZV)["GT.M" O "VPRJT.TXT":(newversion)
 U "VPRJT.TXT"
 Q
RD4HTTP() ; read HTTP body from file and return as value
 N X
 I $$UP($ZV)["CACHE" O "VPRJT.TXT":"RSD" ; read sequential and delete afterwards
 I $$UP($ZV)["GT.M" O "VPRJT.TXT":(readonly:rewind) ; read sequential from the top.
 U "VPRJT.TXT"
 F  R X:1 S X=$TR(X,$C(13)) Q:'$L(X)  ; read lines until there is an empty one ($TR for GT.M)
 R X:2              ; now read the JSON object
 I $$UP($ZV)["GT.M" C "VPRJT.TXT":(delete) U $P
 I $$UP($ZV)["CACHE" D C4HTTP
 Q X
 ;
C4HTTP ; close file used for HTTP response
 C "VPRJT.TXT" U $P
 Q
CRC32(string,seed) ;
 ; Polynomial X**32 + X**26 + X**23 + X**22 +
 ;          + X**16 + X**12 + X**11 + X**10 +
 ;          + X**8  + X**7  + X**5  + X**4 +
 ;          + X**2  + X     + 1
 N I,J,R
 I '$D(seed) S R=4294967295
 E  I seed'<0,seed'>4294967295 S R=4294967295-seed
 E  S $ECODE=",M28,"
 F I=1:1:$L(string) D
 . S R=$$XOR($A(string,I),R,8)
 . F J=0:1:7 D
 . . I R#2 S R=$$XOR(R\2,3988292384,32)
 . . E  S R=R\2
 . . Q
 . Q
 Q 4294967295-R
XOR(a,b,w) N I,M,R
 S R=b,M=1
 F I=1:1:w D
 . S:a\M#2 R=R+$S(R\M#2:-M,1:M)
 . S M=M+M
 . Q
 Q R
BASE(%X1,%X2,%X3) ;Convert %X1 from %X2 base to %X3 base
 I (%X2<2)!(%X2>16)!(%X3<2)!(%X3>16) Q -1
 Q $$CNV($$DEC(%X1,%X2),%X3)
DEC(N,B) ;Cnv N from B to 10
 Q:B=10 N N I,Y S Y=0
 F I=1:1:$L(N) S Y=Y*B+($F("0123456789ABCDEF",$E(N,I))-2)
 Q Y
CNV(N,B) ;Cnv N from 10 to B
 Q:B=10 N N I,Y S Y=""
 F I=1:1 S Y=$E("0123456789ABCDEF",N#B+1)_Y,N=N\B Q:N<1
 Q Y
CRC16(string,seed) ;
 ; Polynomial x**16 + x**15 + x**2 + x**0
 N I,J,R
 I '$D(seed) S R=0
 E  I seed'<0,seed'>65535 S R=seed\1
 E  S $ECODE=",M28,"
 F I=1:1:$L(string) D
 . S R=$$XOR($A(string,I),R,8)
 . F J=0:1:7 D
 . . I R#2 S R=$$XOR(R\2,40961,16)
 . . E  S R=R\2
 . . Q
 . Q
 Q R
 ;
HTFM(%H,%F) ;$H to FM, %F=1 for date only
 N X,%,%T,%Y,%M,%D S:'$D(%F) %F=0
 I $$HR(%H) Q -1 ;Check Range
 I '%F,%H[",0" S %H=(%H-1)_",86400"
 D YMD S:%T&('%F) X=X_%T
 Q X
YMD ;21608 = 28 feb 1900, 94657 = 28 feb 2100, 141 $H base year
 S %=(%H>21608)+(%H>94657)+%H-.1,%Y=%\365.25+141,%=%#365.25\1
 S %D=%+306#(%Y#4=0+365)#153#61#31+1,%M=%-%D\29+1
 S X=%Y_"00"+%M_"00"+%D,%=$P(%H,",",2)
 S %T=%#60/100+(%#3600\60)/100+(%\3600)/100 S:'%T %T=".0"
 Q
HR(%V) ;Check $H in valid range
 Q (%V<2)!(%V>99999)
 ;
HTE(%H,%F) ;$H to external
 Q:$$HR(%H) %H ;Range Check
 N Y,%T,%R
 S %F=$G(%F,1) S Y=$$HTFM(%H,0)
T2 S %T="."_$E($P(Y,".",2)_"000000",1,7)
 D FMT Q %R
FMT ;
 N %G S %G=+%F
 G F1:%G=1,F2:%G=2,F3:%G=3,F4:%G=4,F5:%G=5,F6:%G=6,F7:%G=7,F8:%G=8,F9:%G=9,F1
 Q
 ;
F1 ;Apr 10, 2002
 S %R=$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_$S($E(Y,6,7):$E(Y,6,7)_", ",1:"")_($E(Y,1,3)+1700)
 ;
TM ;All formats come here to format Time.
 N %,%S Q:%T'>0!(%F["D")
 I %F'["P" S %R=%R_"@"_$E(%T,2,3)_":"_$E(%T,4,5)_$S(%F["M":"",$E(%T,6,7)!(%F["S"):":"_$E(%T,6,7),1:"")
 I %F["P" D
 . S %R=%R_" "_$S($E(%T,2,3)>12:$E(%T,2,3)-12,+$E(%T,2,3)=0:"12",1:+$E(%T,2,3))_":"_$E(%T,4,5)_$S(%F["M":"",$E(%T,6,7)!(%F["S"):":"_$E(%T,6,7),1:"")
 . S %R=%R_$S($E(%T,2,7)<120000:" am",$E(%T,2,3)=24:" am",1:" pm")
 . Q
 Q
 ;Return Month names
M() Q "  Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec"
 ;
F2 ;4/10/02
 S %R=$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)_"/"_$E(Y,2,3)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F3 ;10/4/02
 S %R=$J(+$E(Y,6,7),2)_"/"_$J(+$E(Y,4,5),2)_"/"_$E(Y,2,3)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F4 ;02/4/10
 S %R=$E(Y,2,3)_"/"_$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F5 ;4/10/2002
 S %R=$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)_"/"_($E(Y,1,3)+1700)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F6 ;10/4/2002
 S %R=$J(+$E(Y,6,7),2)_"/"_$J(+$E(Y,4,5),2)_"/"_($E(Y,1,3)+1700)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F7 ;2002/4/10
 S %R=($E(Y,1,3)+1700)_"/"_$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F8 ;10 Apr 02
 S %R=$S($E(Y,6,7):$E(Y,6,7)_" ",1:"")_$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_$E(Y,2,3)
 G TM
F9 ;10 Apr 2002
 S %R=$S($E(Y,6,7):$E(Y,6,7)_" ",1:"")_$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_($E(Y,1,3)+1700)
 G TM
 ;
PARSE10(BODY,PARSED) ; Parse BODY by CRLF and return the array in PARSED
 ; Input: BODY: By Ref - BODY to be parsed
 ; Output: PARSED: By Ref - PARSED Output
 ; E.g. if BODY is ABC_CRLF_DEF_CRLF, PARSED is PARSED(1)="ABC",PARSED(2)="DEF",PARSED(3)=""
 N LL S LL="" ; Last line
 N L S L=1 ; Line counter.
 K PARSED ; Kill return array
 N I S I="" F  S I=$O(BODY(I)) Q:'I  D  ; For each 4000 character block
 . N J F J=1:1:$L(BODY(I),$C(10)) D  ; For each line
 . . S:(J=1&(L>1)) L=L-1 ; Replace old line (see 2 lines below)
 . . S PARSED(L)=$TR($P(BODY(I),$C(10),J),$C(13)) ; Get line; Take CR out if there.
 . . S:(J=1&(L>1)) PARSED(L)=LL_PARSED(L) ; If first line, append the last line before it and replace it.
 . . S LL=PARSED(L) ; Set last line
 . . S L=L+1 ; LineNumber++
 QUIT
 ;
ADDCRLF(RESULT) ; Add CRLF to each line
 I $E($G(RESULT))="^" D  QUIT  ; Global
 . N V,QL S V=RESULT,QL=$QL(V) F  S V=$Q(@V) Q:V=""  Q:$NA(@V,QL)'=RESULT  S @V=@V_$C(13,10)
 E  D  ; Local variable passed by reference
 . I $D(RESULT)#2 S RESULT=RESULT_$C(13,10)
 . N V S V=$NA(RESULT) F  S V=$Q(@V) Q:V=""  S @V=@V_$C(13,10)
 QUIT
 ;
TESTCRLF
 S RESULT=$NA(^TMP($J))
 K @RESULT
 S ^TMP($J,1)="HELLO"
 S ^TMP($J,2)="WORLD"
 S ^TMP($J,3)=""
 D ADDCRLF(.RESULT)
 ZWRITE @RESULT@(*)
 K RESULT
 S RESULT="HELLO"
 S RESULT(1)="WORLD"
 S RESULT(2)="BYE"
 S RESULT(3)=""
 D ADDCRLF(.RESULT)
 ZWRITE RESULT
 QUIT
UNKARGS(ARGS,LIST) ; returns true if any argument is unknown
 N X,UNKNOWN
 S UNKNOWN=0,LIST=","_LIST_","
 S X="" F  S X=$O(ARGS(X)) Q:X=""  I LIST'[(","_X_",") D
 . S UNKNOWN=1
 . D SETERROR^VPRJRUT(111,X)
 Q UNKNOWN
 ;
ENCODE64(X) ;
 N RGZ,RGZ1,RGZ2,RGZ3,RGZ4,RGZ5,RGZ6
 S RGZ=$$INIT64,RGZ1=""
 F RGZ2=1:3:$L(X) D
 .S RGZ3=0,RGZ6=""
 .F RGZ4=0:1:2 D
 ..S RGZ5=$A(X,RGZ2+RGZ4),RGZ3=RGZ3*256+$S(RGZ5<0:0,1:RGZ5)
 .F RGZ4=1:1:4 S RGZ6=$E(RGZ,RGZ3#64+2)_RGZ6,RGZ3=RGZ3\64
 .S RGZ1=RGZ1_RGZ6
 S RGZ2=$L(X)#3
 S:RGZ2 RGZ3=$L(RGZ1),$E(RGZ1,RGZ3-2+RGZ2,RGZ3)=$E("==",RGZ2,2)
 Q RGZ1
DECODE64(X) ;
 N RGZ,RGZ1,RGZ2,RGZ3,RGZ4,RGZ5,RGZ6
 S RGZ=$$INIT64,RGZ1=""
 F RGZ2=1:4:$L(X) D
 .S RGZ3=0,RGZ6=""
 .F RGZ4=0:1:3 D
 ..S RGZ5=$F(RGZ,$E(X,RGZ2+RGZ4))-3
 ..S RGZ3=RGZ3*64+$S(RGZ5<0:0,1:RGZ5)
 .F RGZ4=0:1:2 S RGZ6=$C(RGZ3#256)_RGZ6,RGZ3=RGZ3\256
 .S RGZ1=RGZ1_RGZ6
 Q $E(RGZ1,1,$L(RGZ1)-$L(X,"=")+1)
INIT64() Q "=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

VPRJSON
VPRJSON ;SLC/KCM -- Decode/Encode JSON
 ;;1.0;VIRTUAL PATIENT RECORD;**2**;Sep 01, 2011;Build 50
 ;
 ; Note:  Since the routines use closed array references, VVROOT and VVERR
 ;        are used to reduce risk of naming conflicts on the closed array.
 ;
DECODE(VVJSON,VVROOT,VVERR)  ; Set JSON object into closed array ref VVROOT
 ; Examples: D DECODE^VPRJSON("MYJSON","LOCALVAR","LOCALERR")
 ;           D DECODE^VPRJSON("^MYJSON(1)","^GLO(99)","^TMP($J)")
 ;
 ; VVJSON: string/array containing serialized JSON object
 ; VVROOT: closed array reference for M representation of object
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 ;   VVIDX: points to next character in JSON string to process
 ; VVSTACK: manages stack of subscripts
 ;  VVPROP: true if next string is property name, otherwise treat as value
 ;
 G DIRECT^VPRJSOND
 ;
ENCODE(VVROOT,VVJSON,VVERR) ; VVROOT (M structure) --> VVJSON (array of strings)
 ; Examples:  D ENCODE^VPRJSON("^GLO(99,2)","^TMP($J)")
 ;            D ENCODE^VPRJSON("LOCALVAR","MYJSON","LOCALERR")
 ;
 ; VVROOT: closed array reference for M representation of object
 ; VVJSON: destination variable for the string array formatted as JSON
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 G DIRECT^VPRJSONE
 ;
 ;
ESC(X) ; Escape string for JSON
 Q $$ESC^VPRJSONE(X)
 ;
UES(X) ; Unescape JSON string
 Q $$UES^VPRJSOND(X)
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 ; switch (ID) -- XERRX ends statement
 N ERRMSG
 ;
 ; Decode Error Messages
 ;
 I ID="STL{" S ERRMSG="Stack too large for new object." G XERRX
 I ID="SUF}" S ERRMSG="Stack Underflow - extra } found" G XERRX
 I ID="STL[" S ERRMSG="Stack too large for new array." G XERRX
 I ID="SUF]" S ERRMSG="Stack Underflow - extra ] found." G XERRX
 I ID="OBM" S ERRMSG="Array mismatch - expected ] got }." G XERRX
 I ID="ARM" S ERRMSG="Object mismatch - expected } got ]." G XERRX
 I ID="MPN" S ERRMSG="Missing property name." G XERRX
 I ID="EXT" S ERRMSG="Expected true, got "_VAL G XERRX
 I ID="EXF" S ERRMSG="Expected false, got "_VAL G XERRX
 I ID="EXN" S ERRMSG="Expected null, got "_VAL G XERRX
 I ID="TKN" S ERRMSG="Unable to identify type of token, value was "_VAL G XERRX
 I ID="SCT" S ERRMSG="Stack mismatch - exit stack level was  "_VAL G XERRX
 I ID="EIQ" S ERRMSG="Close quote not found before end of input." G XERRX
 I ID="EIU" S ERRMSG="Unexpected end of input while unescaping." G XERRX
 I ID="RSB" S ERRMSG="Reverse search for \ past beginning of input." G XERRX
 I ID="ORN" S ERRMSG="Overrun while scanning name." G XERRX
 I ID="OR#" S ERRMSG="Overrun while scanning number." G XERRX
 I ID="ORB" S ERRMSG="Overrun while scanning boolean." G XERRX
 I ID="ESC" S ERRMSG="Escaped character not recognized"_VAL G XERRX
 ;
 ; Encode Error Messages
 ;
 I ID="SOB" S ERRMSG="Unable to serialize node as object, value was "_VAL G XERRX
 I ID="SAR" S ERRMSG="Unable to serialize node as array, value was "_VAL G XERRX
 S ERRMSG="Unspecified error "_ID_" "_$G(VAL)
XERRX ; end switch
 S @VVERR@(0)=$G(@VVERR@(0))+1
 S @VVERR@(@VVERR@(0))=ERRMSG
 S VVERRORS=VVERRORS+1
 Q

VPRJSOND
VPRJSOND ;SLC/KCM -- Decode JSON
 ;;1.0;VIRTUAL PATIENT RECORD;**2**;Sep 01, 2011;Build 50
 ;
 ; VEN/SMH - bug fixes to prevent psudo-numberic arrays from 
 ; being thought as a JSON array: it's an object.
 ;
DECODE(VVJSON,VVROOT,VVERR) ; Set JSON object into closed array ref VVROOT
 ;
DIRECT ; TAG for use by DECODE^VPRJSON
 ;
 ; Examples: D DECODE^VPRJSON("MYJSON","LOCALVAR","LOCALERR")
 ;           D DECODE^VPRJSON("^MYJSON(1)","^GLO(99)","^TMP($J)")
 ;
 ; VVJSON: string/array containing serialized JSON object
 ; VVROOT: closed array reference for M representation of object
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 ;   VVIDX: points to next character in JSON string to process
 ; VVSTACK: manages stack of subscripts
 ;  VVPROP: true if next string is property name, otherwise treat as value
 ;
 N VVMAX S VVMAX=4000 ; limit document lines to 4000 characters
 S VVERR=$G(VVERR,"^TMP(""VPRJERR"",$J)")
 ; If a simple string is passed in, move it to an temp array (VVINPUT)
 ; so that the processing is consistently on an array.
 I $D(@VVJSON)=1 N VVINPUT S VVINPUT(1)=@VVJSON,VVJSON="VVINPUT"
 S VVROOT=$NA(@VVROOT@("Z")),VVROOT=$E(VVROOT,1,$L(VVROOT)-4) ; make open array ref
 N VVLINE,VVIDX,VVSTACK,VVPROP,VVTYPE,VVERRORS
 S VVLINE=$O(@VVJSON@("")),VVIDX=1,VVSTACK=0,VVPROP=0,VVERRORS=0
 F  S VVTYPE=$$NXTKN() Q:VVTYPE=""  D  I VVERRORS Q
 . I VVTYPE="{" S VVSTACK=VVSTACK+1,VVSTACK(VVSTACK)="",VVPROP=1 D:VVSTACK>64 ERRX("STL{") Q
 . ; I VVTYPE="}" D:VVSTACK(VVSTACK) ERRX("OBM") S VVSTACK=VVSTACK-1 D:VVSTACK<0 ERRX("SUF}") Q  ;VEN/SMH - old
 . I VVTYPE="}" D  QUIT
 . . I +VVSTACK(VVSTACK)=VVSTACK(VVSTACK),VVSTACK(VVSTACK) D ERRX("OBM") ; Numeric and true only
 . . S VVSTACK=VVSTACK-1 D:VVSTACK<0 ERRX("SUF}") 
 . I VVTYPE="[" S VVSTACK=VVSTACK+1,VVSTACK(VVSTACK)=1 D:VVSTACK>64 ERRX("STL[") Q
 . I VVTYPE="]" D:'VVSTACK(VVSTACK) ERRX("ARM") S VVSTACK=VVSTACK-1 D:VVSTACK<0 ERRX("SUF]") Q  ; VEN/SMH - don't chk. Must be number.
 . I VVTYPE="," D  QUIT
 . . ;I VVSTACK(VVSTACK) S VVSTACK(VVSTACK)=VVSTACK(VVSTACK)+1  ; next in array  ; VEN/SMH - old
 . . I +VVSTACK(VVSTACK)=VVSTACK(VVSTACK),VVSTACK(VVSTACK) S VVSTACK(VVSTACK)=VVSTACK(VVSTACK)+1  ; VEN/SMH - next in array
 . . E  S VVPROP=1                                   ; or next property name
 . I VVTYPE=":" S VVPROP=0 D:'$L($G(VVSTACK(VVSTACK))) ERRX("MPN") Q
 . I VVTYPE="""" D  Q
 . . I VVPROP S VVSTACK(VVSTACK)=$$NAMPARS() I 1
 . . E  D ADDSTR
 . S VVTYPE=$TR(VVTYPE,"TFN","tfn")
 . I VVTYPE="t" D  Q
 . . I $TR($E(@VVJSON@(VVLINE),VVIDX,VVIDX+2),"RUE","rue")="rue" D SETBOOL("true") I 1
 . . E  D ERRX("EXT",VVTYPE)
 . I VVTYPE="f" D  Q
 . . I $TR($E(@VVJSON@(VVLINE),VVIDX,VVIDX+3),"ALSE","alse")="alse" D SETBOOL("false") I 1
 . . E  D ERRX("EXF",VVTYPE)
 . I VVTYPE="n" D  Q
 . . I $TR($E(@VVJSON@(VVLINE),VVIDX,VVIDX+2),"ULL","ull")="ull" D SETBOOL("null") I 1
 . . E  D ERRX("EXN",VVTYPE)
 . I "0123456789+-.eE"[VVTYPE S @$$CURNODE()=$$NUMPARS(VVTYPE) Q
 . D ERRX("TKN",VVTYPE)
 I VVSTACK'=0 D ERRX("SCT",VVSTACK)
 Q
NXTKN() ; Move the pointers to the beginning of the next token
 N VVDONE,VVEOF,VVTOKEN
 S VVDONE=0,VVEOF=0 F  D  Q:VVDONE!VVEOF  ; eat spaces & new lines until next visible char
 . I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=$O(@VVJSON@(VVLINE)),VVIDX=1 I 'VVLINE S VVEOF=1 Q
 . I $A(@VVJSON@(VVLINE),VVIDX)>32 S VVDONE=1 Q
 . S VVIDX=VVIDX+1
 Q:VVEOF ""  ; we're at the end of input
 S VVTOKEN=$E(@VVJSON@(VVLINE),VVIDX),VVIDX=VVIDX+1
 Q VVTOKEN
 ;
ADDSTR ; Add string value to current node, escaping text along the way
 ; Expects VVLINE,VVIDX to reference that starting point of the index
 ; TODO: add a mechanism to specify names that should not be escaped
 ;       just store as ":")= and ":",n)=
 ;
 ; Happy path -- we find the end quote in the same line
 N VVEND,VVX
 S VVEND=$F(@VVJSON@(VVLINE),"""",VVIDX)
 I VVEND,($E(@VVJSON@(VVLINE),VVEND-2)'="\") D SETSTR  QUIT  ;normal
 I VVEND,$$ISCLOSEQ(VVLINE) D SETSTR QUIT  ;close quote preceded by escaped \
 ;
 ; Less happy path -- first quote wasn't close quote
 N VVDONE,VVTLINE
 S VVDONE=0,VVTLINE=VVLINE ; VVTLINE for temporary increment of VVLINE
 F  D  Q:VVDONE  Q:VVERRORS
 . ;if no quote on current line advance line, scan again
 . I 'VVEND S VVTLINE=VVTLINE+1,VVEND=1 I '$D(@VVJSON@(VVTLINE)) D ERRX("EIQ") Q
 . S VVEND=$F(@VVJSON@(VVTLINE),"""",VVEND)
 . I VVEND,$E(@VVJSON@(VVTLINE),VVEND-2)'="\" S VVDONE=1 Q  ; found quote position
 . S VVDONE=$$ISCLOSEQ(VVTLINE) ; see if this is an escaped quote or closing quote
 Q:VVERRORS
 ; unescape from VVIDX to VVEND, using \-extension nodes as necessary
 D UESEXT
 ; now we need to move VVLINE and VVIDX to next parsing point
 S VVLINE=VVTLINE,VVIDX=VVEND
 Q
SETSTR ; Set simple string value from within same line
 ; expects VVJSON, VVLINE, VVINX, VVEND
 N VVX
 S VVX=$E(@VVJSON@(VVLINE),VVIDX,VVEND-2),VVIDX=VVEND
 S @$$CURNODE()=$$UES(VVX)
 I +VVX=VVX S @$$CURNODE()@("\s")=""
 ;S vX=$S(+vX=vX:$C(186)_vX,1:$$UES(vX))
 ;S @$$CURNODE()=vX
 I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=VVLINE+1,VVIDX=1
 Q
UESEXT ; unescape from VVLINE,VVIDX to VVTLINE,VVEND & extend (\) if necessary
 ; expects VVLINE,VVIDX,VVTLINE,VVEND
 N VVI,VVY,VVSTART,VVSTOP,VVDONE,VVBUF,VVNODE,VVMORE,VVTO
 S VVNODE=$$CURNODE(),VVBUF="",VVMORE=0,VVSTOP=VVEND-2
 S VVI=VVIDX,VVY=VVLINE,VVDONE=0
 F  D  Q:VVDONE  Q:VVERRORS
 . S VVSTART=VVI,VVI=$F(@VVJSON@(VVY),"\",VVI)
 . ; if we are on the last line, don't extract past VVSTOP
 . I (VVY=VVTLINE) S VVTO=$S('VVI:VVSTOP,VVI>VVSTOP:VVSTOP,1:VVI-2) I 1
 . E  S VVTO=$S('VVI:99999,1:VVI-2)
 . D ADDBUF($E(@VVJSON@(VVY),VVSTART,VVTO))
 . I (VVY'<VVTLINE),(('VVI)!(VVI>VVSTOP)) S VVDONE=1 QUIT  ; now past close quote
 . I 'VVI S VVY=VVY+1,VVI=1 QUIT  ; nothing escaped, go to next line
 . I VVI>$L(@VVJSON@(VVY)) S VVY=VVY+1,VVI=1 I '$D(@VVJSON@(VVY)) D ERRX("EIU")
 . D ADDBUF($$REALCHAR($E(@VVJSON@(VVY),VVI)))
 . S VVI=VVI+1
 . I (VVY'<VVTLINE),(VVI>VVSTOP) S VVDONE=1 ; VVI incremented past stop
 Q:VVERRORS
 D SAVEBUF
 Q
ADDBUF(VVX) ; add buffer of characters to destination
 ; expects VVBUF,VVMAX,VVNODE,VVMORE to be defined
 ; used directly by ADDSTR
 I $L(VVX)+$L(VVBUF)>VVMAX D SAVEBUF
 S VVBUF=VVBUF_VVX
 Q
SAVEBUF ; write out buffer to destination
 ; expects VVBUF,VVMAX,VVNODE,VVMORE to be defined
 ; used directly by ADDSTR,ADDBUF
 I 'VVMORE S @VVNODE=VVBUF S:+VVBUF=VVBUF @VVNODE@("\s")="" I 1 ;$S(+VVBUF=VVBUF:$C(186)_VVBUF,1:VVBUF)
 E  S @VVNODE@("\",VVMORE)=VVBUF
 S VVMORE=VVMORE+1,VVBUF=""
 Q
ISCLOSEQ(VVBLINE) ; return true if this is a closing, rather than escaped, quote
 ; expects VVJSON, VVIDX, VVEND
 ; always called directly from ADDSTR
 N VVBACK,VVBIDX
 S VVBACK=0,VVBIDX=VVEND-2
 ; starting at VVEND-2 means looking at the char right before the \
 ; if it is not \, then the \ was escaping the quote
 F  D  Q:$E(@VVJSON@(VVBLINE),VVBIDX)'="\"  Q:VVERRORS
 . S VVBACK=VVBACK+1,VVBIDX=VVBIDX-1
 . I (VVBLINE=VVLINE),(VVBIDX=VVIDX) Q  ; back at the open quote
 . Q:VVBIDX
 . ; when VVBIDX<1 go back a line
 . S VVBLINE=VVBLINE-1 I VVBLINE<VVLINE D ERRX("RSB") Q
 . S VVBIDX=$L(@VVJSON@(VVBLINE))
 Q VVBACK#2=0  ; VVBACK is even if this is a close quote
 ;
NAMPARS() ; Return parsed name, advancing index past the close quote
 ; -- This assumes no embedded quotes are in the name itself --
 N VVEND,VVDONE,VVNAME
 S VVDONE=0,VVNAME=""
 F  D  Q:VVDONE  Q:VVERRORS
 . S VVEND=$F(@VVJSON@(VVLINE),"""",VVIDX)
 . I VVEND S VVNAME=VVNAME_$E(@VVJSON@(VVLINE),VVIDX,VVEND-2),VVIDX=VVEND,VVDONE=1
 . I 'VVEND S VVNAME=VVNAME_$E(@VVJSON@(VVLINE),VVIDX,$L(@VVJSON@(VVLINE)))
 . I 'VVEND!(VVEND>$L(@VVJSON@(VVLINE))) S VVLINE=VVLINE+1,VVIDX=1 I '$D(@VVJSON@(VVLINE)) D ERRX("ORN")
 Q VVNAME
 ;
NUMPARS(VVDIGIT) ; Return parsed number, advancing index past the end of the number
 ; VVIDX intially references the second digit
 N VVDONE,VVNUM
 S VVDONE=0,VVNUM=VVDIGIT
 F  D  Q:VVDONE  Q:VVERRORS
 . I '("0123456789+-.eE"[$E(@VVJSON@(VVLINE),VVIDX)) S VVDONE=1 Q
 . S VVNUM=VVNUM_$E(@VVJSON@(VVLINE),VVIDX)
 . S VVIDX=VVIDX+1 I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=VVLINE+1,VVIDX=1 I '$D(@VVJSON@(VVLINE)) D ERRX("OR#")
 Q VVNUM
 ;
SETBOOL(VVX) ; set a value and increment VVIDX
 S @$$CURNODE()=VVX
 S VVIDX=VVIDX+$L(VVX)-1
 N VVDIFF S VVDIFF=VVIDX-$L(@VVJSON@(VVLINE))  ; in case VVIDX moves to next line
 I VVDIFF>0 S VVLINE=VVLINE+1,VVIDX=VVDIFF I '$D(@VVJSON@(VVLINE)) D ERRX("ORB")
 Q
CURNODE() ; Return a global/local variable name based on VVSTACK
 ; Expects VVSTACK to be defined already
 N VVI,VVSUBS
 S VVSUBS=""
 F VVI=1:1:VVSTACK S:VVI>1 VVSUBS=VVSUBS_"," D
 . ;I VVSTACK(VVI) S VVSUBS=VVSUBS_VVSTACK(VVI) ; ven/smh - OLD
 . I VVSTACK(VVI)=+VVSTACK(VVI) S VVSUBS=VVSUBS_VVSTACK(VVI) ; VEN/SMH - NEW. Fix psudo array bug.
 . E  S VVSUBS=VVSUBS_""""_VVSTACK(VVI)_""""
 Q VVROOT_VVSUBS_")"
 ;
UES(X) ; Unescape JSON string
 ; copy segments from START to POS-2 (right before \)
 ; translate target character (which is at $F position)
 N POS,Y,START
 S POS=0,Y=""
 F  S START=POS+1 D  Q:START>$L(X)
 . S POS=$F(X,"\",POS+1) ; find next position
 . I 'POS S Y=Y_$E(X,START,$L(X)),POS=$L(X) I 1
 . E  S Y=Y_$E(X,START,POS-2)_$$REALCHAR($E(X,POS))
 . ;S:'POS POS=$L(X)+2  ; get the rest of the string
 . ;S Y=Y_$E(X,START,POS-2)_$$REALCHAR($E(X,POS))
 Q Y
 ;
REALCHAR(C) ; Return actual character from escaped
 I C="""" Q """"
 I C="/" Q "/"
 I C="\" Q "\"
 I C="b" Q $C(8)
 I C="f" Q $C(12)
 I C="n" Q $C(10)
 I C="r" Q $C(13)
 I C="t" Q $C(9)
 I C="u" ;TODO add case for 4-hex-digits (U000A, for example)
 ;otherwise
 I $L($G(VVERR)) D ERRX("ESC",C)
 Q C
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 D ERRX^VPRJSON(ID,$G(VAL))
 Q

VPRJSONE
VPRJSONE ;SLC/KCM -- Encode JSON;2013-10-25  1:48 AM
 ;;1.0;VIRTUAL PATIENT RECORD;**2,%W**;Sep 01, 2011;Build 50
 ;
ENCODE(VVROOT,VVJSON,VVERR) ; VVROOT (M structure) --> VVJSON (array of strings)
 ;
DIRECT ; TAG for use by ENCODE^VPRJSON
 ;
 ; Examples:  D ENCODE^VPRJSON("^GLO(99,2)","^TMP($J)")
 ;            D ENCODE^VPRJSON("LOCALVAR","MYJSON","LOCALERR")
 ;
 ; VVROOT: closed array reference for M representation of object
 ; VVJSON: destination variable for the string array formatted as JSON
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 S VVERR=$G(VVERR,"^TMP(""VPRJERR"",$J)")
 I '$L($G(VVROOT)) ; set error info
 I '$L($G(VVJSON)) ; set error info
 N VVLINE,VVMAX,VVERRORS
 S VVLINE=1,VVMAX=4000,VVERRORS=0  ; 96 more bytes of wiggle room
 S @VVJSON@(VVLINE)=""
 D SEROBJ(VVROOT)
 Q
 ;
SEROBJ(VVROOT) ; Serialize into a JSON object
 N VVFIRST,VVSUB,VVNXT
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"{"
 S VVFIRST=1
 S VVSUB="" F  S VVSUB=$O(@VVROOT@(VVSUB)) Q:VVSUB=""  D
 . S:'VVFIRST @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"," S VVFIRST=0
 . ; get the name part
 . D SERNAME(VVSUB)
 . ; if this is a value, serialize it
 . I $$ISVALUE(VVROOT,VVSUB) D SERVAL(VVROOT,VVSUB) Q
 . ; otherwise navigate to the next child object or array
 . I $D(@VVROOT@(VVSUB))>9 S VVNXT=$O(@VVROOT@(VVSUB,"")) D  Q  ; VEN/SMH Changed $D from =10 to >9 to capture 11 as well
 . . I +VVNXT D SERARY($NA(@VVROOT@(VVSUB))) I 1
 . . E  D SEROBJ($NA(@VVROOT@(VVSUB)))
 . D ERRX("SOB",VVSUB)  ; should quit loop before here
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"}"
 Q
SERARY(VVROOT) ; Serialize into a JSON array
 N VVFIRST,VVI,VVNXT
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"["
 S VVFIRST=1
 S VVI=0 F  S VVI=$O(@VVROOT@(VVI)) Q:'VVI  D
 . S:'VVFIRST @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"," S VVFIRST=0
 . I $$ISVALUE(VVROOT,VVI) D SERVAL(VVROOT,VVI) Q  ; write value
 . I $D(@VVROOT@(VVI))=10 S VVNXT=$O(@VVROOT@(VVI,"")) D  Q
 . . ; I +VVNXT D SERARY($NA(@VVROOT@(VVI))) I 1  ; VEN/SMH - this isn't cutting it for me...
 . . I +VVNXT=VVNXT D SERARY($NA(@VVROOT@(VVI))) I 1  ; If numeric... another array inside array
 . . E  D SEROBJ($NA(@VVROOT@(VVI))) ; otherwise, it's an object
 . D ERRX("SAR",VVI)  ; should quit loop before here
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"]"
 Q
SERNAME(VVSUB) ; Serialize the object name into JSON string
 I ($L(VVSUB)+$L(@VVJSON@(VVLINE)))>VVMAX S VVLINE=VVLINE+1,@VVJSON@(VVLINE)=""
 ; S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_""""_VVSUB_""""_":" VEN/SMH - needs escaping too!
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_""""_$$ESC(VVSUB)_""""_":"
 Q
SERVAL(VVROOT,VVSUB) ; Serialize X into appropriate JSON representation
 N VVX,VVI
 ; if the node is already in JSON format, just add it
 I $D(@VVROOT@(VVSUB,":")) D  QUIT  ; <-- jump out here if preformatted
 . S VVX=$G(@VVROOT@(VVSUB,":")) D:$L(VVX) CONCAT
 . S VVI=0 F  S VVI=$O(@VVROOT@(VVSUB,":",VVI)) Q:'VVI  S VVX=@VVROOT@(VVSUB,":",VVI) D CONCAT
 ;
 S VVX=$G(@VVROOT@(VVSUB))
 ; handle the numeric, boolean, and null types
 I '$D(@VVROOT@(VVSUB,"\s")),$$NUMERIC(VVX) D CONCAT QUIT
 I (VVX="true")!(VVX="false")!(VVX="null") D CONCAT QUIT
 ;I $E(vX)=$C(186) S vX=$E(vX,2,$L(vX)) ; remove the "string-forcing" char
 ; otherwise treat it as a string type
 S VVX=""""_$$ESC(VVX) ; open quote
 D CONCAT
 I $D(@VVROOT@(VVSUB,"\")) D  ; handle continuation nodes
 . S VVI=0 F  S VVI=$O(@VVROOT@(VVSUB,"\",VVI)) Q:'VVI   D
 . . S VVX=$$ESC(@VVROOT@(VVSUB,"\",VVI))
 . . D CONCAT
 S VVX="""" D CONCAT    ; close quote
 Q
CONCAT ; come here to concatenate to JSON string
 I ($L(VVX)+$L(@VVJSON@(VVLINE)))>VVMAX S VVLINE=VVLINE+1,@VVJSON@(VVLINE)=""
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_VVX
 Q
ISVALUE(VVROOT,VVSUB) ; Return true if this is a value node
 I $D(@VVROOT@(VVSUB))#2,$NA(@VVROOT@(VVSUB))=@VVROOT@(VVSUB) Q 0  ; VEN/SMH ; Global node for multiples in Fileman
 I $D(@VVROOT@(VVSUB))#2 Q 1
 N VVX S VVX=$O(@VVROOT@(VVSUB,""))
 Q:VVX="\" 1
 Q:VVX=":" 1
 Q 0
 ;
NUMERIC(X) ; Return true if the numeric
 I X=0 Q 1        ; numeric (value is zero)
 I +X=0 Q 0       ; string
 I X?1"."1.N Q 0  ; string (value begins with decimal)
 I +X=X Q 1       ; numeric
 S X=$TR(X,"e","E")
 I X?.1"-"1.N.1".".N1"E".1"+"1.N Q 1
 I X?.1"-"1.N.1".".N1"E-"1.N Q 1
 Q 0
 ;
ESC(X) ; Escape string for JSON
 N Y,I,PAIR,FROM,TO
 S Y=X
 F PAIR="\\","""""","//",$C(8,98),$C(12,102),$C(10,110),$C(13,114),$C(9,116) D
 . S FROM=$E(PAIR),TO=$E(PAIR,2)
 . S X=Y,Y=$P(X,FROM) F I=2:1:$L(X,FROM) S Y=Y_"\"_TO_$P(X,FROM,I)
 Q Y
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 D ERRX^VPRJSON(ID,$G(VAL))
 Q

VPRJTJD
VPRJTJD ;SLC/KCM -- Unit tests for JSON decoding
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 D EN^XTMUNIT($T(+0),1) QUIT
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D CHKEQ^XTMUNIT(EXPECT,ACTUAL)
 Q
 ;
JSONUES ;; @TEST unescape JSON encoded string
 N X
 S X=$$UES^VPRJSON("String with \\ in the middle")
 D ASSERT("String with \ in the middle",X)
 S X=$$UES^VPRJSON("\\ is the first character of this string")
 D ASSERT("\ is the first character of this string",X)
 S X=$$UES^VPRJSON("The last character of this string is \\")
 D ASSERT("The last character of this string is \",X)
 S X=$$UES^VPRJSON("\\one\\two\\three\\")
 D ASSERT("\one\two\three\",X)
 S X=$$UES^VPRJSON("A vee shape: \\\/\tTABBED\tand line endings.\n\r\f")
 D ASSERT("A vee shape: \/"_$C(9)_"TABBED"_$C(9)_"and line endings."_$C(10,13,12),X)
 S X=$$UES^VPRJSON("\""This text is quoted\""")
 D ASSERT("""This text is quoted""",X)
 Q
SPLITA ;; @TEST JSON input with escaped characters on single line
 N JSON,Y,ERR,ESC
 S ESC="this string contains \and other escaped characters such as "_$c(10)
 S ESC=ESC_"  and a few tabs "_$c(9,9,9,9)_" and a piece of ""quoted text"""
 D BUILD("SPLIT",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(ESC,$G(Y("esc")))
 D ASSERT("this is a new line",$G(Y("next")))
 D ASSERT("this is a string that goes across two lines",$G(Y("wp")))
 D ASSERT("here is another string",$G(Y("nextLineQuote")))
 Q
SPLITB ;; @TEST multiple line JSON input with lines split across tokens
 N JSON,Y,ERR,ESC
 S ESC="this string contains \and other escaped characters such as "_$c(10)
 S ESC=ESC_"  and a few tabs "_$c(9,9,9,9)_" and a piece of ""quoted text"""
 D BUILDA("SPLIT",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(ESC,$G(Y("esc")))
 D ASSERT("this is a new line",$G(Y("next")))
 D ASSERT("this is a string that goes across two lines",$G(Y("wp")))
 D ASSERT("here is another string",$G(Y("nextLineQuote")))
 Q
LONG ;; @TEST long document that must be saved across extension nodes
 N JSON,Y,ERR,I,LINE
 S JSON(1)="{""title"":""long document"",""size"":""rather large"",""document"":"""
 S LINE="This is a line of text intended to test longer documents.\r\n  It will be repeated so that there are several nodes that must be longer than 4000 kilobytes."
 F I=2:1:100 S JSON(I)=LINE
 S JSON(101)=""",""author"":""WINDED,LONG""}"
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(3978,$L(Y("document")))
 D ASSERT(3213,$L(Y("document","\",3)))
 D ASSERT(0,$D(Y("document",4)))
 D ASSERT("WINDED,LONG",Y("author"))
 D ASSERT("rather large",Y("size"))
 Q
FRAC ;; @TEST multiple lines with fractional array elements
 ;; {"title":"my array of stuff", "count":3, "items": [
 ;; {"name":"red", "rating":"ok"},
 ;; {"name":"blue", "rating":"good"},
 ;; {"name":"purple", "rating":"outstanding"}
 ;; ]}
 N JSON,Y,ERR
 S JSON(0)=$P($T(FRAC+1),";;",2,99)
 S JSON(.5)=$P($T(FRAC+2),";;",2,99)
 S JSON(1)=$P($T(FRAC+3),";;",2,99)
 S JSON(1.1)=$P($T(FRAC+4),";;",2,99)
 S JSON(1.2)=$P($T(FRAC+5),";;",2,99)
 S JSON("JUNK")="Junk non-numeric node -- this should be ignored"
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("purple",Y("items",3,"name"))
 Q
VALONLY ;; @TEST passing in value only -- not array
 N JSON,Y,ERR
 S JSON=$P($T(VALONLY+1^VPRJTJDD),";;",2,999)
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("urn:va:param:F484:1120:VPR USER PREF:1120",Y("uid"))
 D ASSERT("north",Y("vals","cpe.patientpicker.loc"))
 Q
NUMERIC ;; @TEST passing in numeric types and strings
 N JSON,Y,ERR
 S JSON=$P($T(NUMERIC+1^VPRJTJDD),";;",2,999)
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(234567,+Y("count")) ; make sure it's numeric
 D ASSERT(20120919,Y("hl7Time"))
 D ASSERT(1,$D(Y("hl7Time","\s")))
 D ASSERT("722.10",Y("icd"))
 D ASSERT(0,+Y("icd")="722.10") ; make sure it's a string
 Q
BADQUOTE ;; @TEST poorly formed JSON (missing close quote on LABEL)
 N JSON,Y,ERR
 D BUILD("BADQUOTE",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(1,$D(ERR)>0)
 Q
BADSLASH ;; @TEST poorly formed JSON (non-escaped backslash)
 N JSON,Y,ERR
 D BUILD("BADSLASH",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(1,$D(ERR)>0)
 Q
PSNUM ;; @TEST subjects that look like a numbers shouldn't be encoded as numbers
 N JSON,Y,ERR
 D BUILD("PSNUM",.JSON)
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(Y("0.85,0.01","AUDIT"),"TEST1")
 D ASSERT(Y("0.85,0.02","AUDIT"),"TEST3")
 D ASSERT(Y("0.85,0.03","AUDIT"),"TEST5")
 QUIT
SAM1 ;; @TEST decode sample 1 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM1",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("file",$G(Y("menu","id")))
 D ASSERT("OpenDoc()",$G(Y("menu","popup","menuitem",2,"onclick")))
 Q
SAM2 ;; @TEST decode sample 2 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM2",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("XML",$G(Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",2)))
 D ASSERT("SGML",$G(Y("glossary","GlossDiv","GlossList","GlossEntry","SortAs")))
 Q
SAM3 ;; @TEST decode sample 3 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM3",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(500,$G(Y("widget","window","width")))
 D ASSERT("sun1.opacity = (sun1.opacity / 100) * 90;",$G(Y("widget","text","onMouseUp")))
 D ASSERT("Sample Konfabulator Widget",$G(Y("widget","window","title")))
 Q
SAM4 ;; @TEST decode sample 4 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM4",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(0,$D(Y("web-app","servlet",6)))  ; should only be 5 servlets
 D ASSERT(1,$G(Y("web-app","servlet",5,"init-param","log")))
 D ASSERT("/usr/local/tomcat/logs/CofaxTools.log",$G(Y("web-app","servlet",5,"init-param","logLocation")))
 D ASSERT("/",$G(Y("web-app","servlet-mapping","cofaxCDS")))
 D ASSERT("/WEB-INF/tlds/cofax.tld",$G(Y("web-app","taglib","taglib-location")))
 Q
SAM5 ;; @TEST decode sample 5 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM5",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(0,$D(Y("menu","items",23)))  ; should only be 22 items
 D ASSERT("About Adobe CVG Viewer...",$G(Y("menu","items",22,"label")))
 D ASSERT("null",$G(Y("menu","items",3)))
 Q
 ;
BUILD(TAG,JSON) ; Build array of strings in JSON for TAG
 N X,I,LINE
 S LINE=1,JSON(LINE)=""
 F I=1:1 S X=$E($T(@TAG+I^VPRJTJDD),4,999) Q:X="#####"  D
 . I $L(JSON(LINE))+$L(X)>4000 S LINE=LINE+1,JSON(LINE)=""
 . S JSON(LINE)=JSON(LINE)_X
 Q
BUILDA(TAG,JSON) ; Build array of string in JSON with splits preserved
 N X,I
 F I=1:1 S X=$E($T(@TAG+I^VPRJTJDD),4,999) Q:X="#####"  S JSON(I)=X
 Q

VPRJTJDD
VPRJTJDD ;SLC/KCM -- Unit test data for JSON decoding
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;
 ; --- Data for multi-line tests
 ;
SPLIT ;
 ;;{"name":"value","comments":"here comes some whitespace"     
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a 
 ;;string that goes across two lines", "esc": "this string contains \\
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; a piece of \"quoted text\"", "nextLineQuote":"here is another string
 ;;"} 
 ;;#####
 ;
VALONLY ;
 ;;{"uid":"urn:va:param:F484:1120:VPR USER PREF:1120","entity":"USR","entityId":"1120","param":"VPR USER PREF","instance":"1120","vals":{"ext.libver":"/lib/ext-4.0.7/ext-all-dev.js","cpe.patientpicker.loc":"north"}}
 ;
NUMERIC ;
 ;;{"name":"Duck,Donald","hl7Time":"20120919","count":234567,"icd":"722.10"}
BADQUOTE ;
 ;;{"name":"value","comments":"here comes some whitespace"     
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a 
 ;;string that goes across two lines", "esc: "this string contains \\
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; a piece of \"quoted text\"", "nextLineQuote":"here is another string
 ;;"} 
 ;;#####
 ;
BADSLASH ;
 ;;{"name":"value","comments":"here comes some whitespace"     
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a 
 ;;string that goes across two lines", "esc": "this string contains \
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; a piece of \"quoted text\"", "nextLineQuote":"here is another string
 ;;"} 
 ;;#####
 ;
 ; --- SAMPLE JSON strings
 ;
SAM1 ;
 ;;{"menu":{"id":"file","popup":{"menuitem":[{"value": "New","onclick":"CreateNewDoc()"},
 ;;{"value": "Open","onclick": "OpenDoc()"},{"value": "Close","onclick": "CloseDoc()"}]} ,
 ;;"value":"File"}}
 ;;#####
 ;
SAM2 ;
 ;;    {
 ;;        "glossary": {
 ;;            "title": "example glossary",
 ;;            "GlossDiv": {
 ;;                "title": "S",
 ;;                "GlossList": {
 ;;                    "GlossEntry": {
 ;;                        "ID": "SGML",
 ;;                        "SortAs": "SGML",
 ;;                        "GlossTerm": "Standard Generalized Markup Language",
 ;;                        "Acronym": "SGML",
 ;;                        "Abbrev": "ISO 8879:1986",
 ;;                        "GlossDef": {
 ;;                            "para": "A meta-markup language, used to create markup languages such as DocBook.",
 ;;                            "GlossSeeAlso": ["GML", "XML"]
 ;;                        },
 ;;                        "GlossSee": "markup"
 ;;                    }
 ;;                }
 ;;            }
 ;;        }
 ;;    }
 ;;#####
 ;    
SAM3 ;
 ;;    {"widget": {
 ;;        "debug": "on",
 ;;        "window": {
 ;;            "title": "Sample Konfabulator Widget",
 ;;            "name": "main_window",
 ;;            "width": 500,
 ;;            "height": 500
 ;;        },
 ;;        "image": { 
 ;;            "src": "Images/Sun.png",
 ;;            "name": "sun1",
 ;;            "hOffset": 250,
 ;;            "vOffset": 250,
 ;;            "alignment": "center"
 ;;        },
 ;;        "text": {
 ;;            "data": "Click Here",
 ;;            "size": 36,
 ;;            "style": "bold",
 ;;            "name": "text1",
 ;;            "hOffset": 250,
 ;;            "vOffset": 100,
 ;;            "alignment": "center",
 ;;            "onMouseUp": "sun1.opacity = (sun1.opacity / 100) * 90;"
 ;;        }
 ;;    }}    
 ;;#####
 ;
SAM4 ;    
 ;;    {"web-app": {
 ;;      "servlet": [   
 ;;        {
 ;;          "servlet-name": "cofaxCDS",
 ;;          "servlet-class": "org.cofax.cds.CDSServlet",
 ;;          "init-param": {
 ;;            "configGlossary:installationAt": "Philadelphia, PA",
 ;;            "configGlossary:adminEmail": "ksm@pobox.com",
 ;;            "configGlossary:poweredBy": "Cofax",
 ;;            "configGlossary:poweredByIcon": "/images/cofax.gif",
 ;;            "configGlossary:staticPath": "/content/static",
 ;;            "templateProcessorClass": "org.cofax.WysiwygTemplate",
 ;;            "templateLoaderClass": "org.cofax.FilesTemplateLoader",
 ;;            "templatePath": "templates",
 ;;            "templateOverridePath": "",
 ;;            "defaultListTemplate": "listTemplate.htm",
 ;;            "defaultFileTemplate": "articleTemplate.htm",
 ;;            "useJSP": false,
 ;;            "jspListTemplate": "listTemplate.jsp",
 ;;            "jspFileTemplate": "articleTemplate.jsp",
 ;;            "cachePackageTagsTrack": 200,
 ;;            "cachePackageTagsStore": 200,
 ;;            "cachePackageTagsRefresh": 60,
 ;;            "cacheTemplatesTrack": 100,
 ;;            "cacheTemplatesStore": 50,
 ;;            "cacheTemplatesRefresh": 15,
 ;;            "cachePagesTrack": 200,
 ;;            "cachePagesStore": 100,
 ;;            "cachePagesRefresh": 10,
 ;;            "cachePagesDirtyRead": 10,
 ;;            "searchEngineListTemplate": "forSearchEnginesList.htm",
 ;;            "searchEngineFileTemplate": "forSearchEngines.htm",
 ;;            "searchEngineRobotsDb": "WEB-INF/robots.db",
 ;;            "useDataStore": true,
 ;;            "dataStoreClass": "org.cofax.SqlDataStore",
 ;;            "redirectionClass": "org.cofax.SqlRedirection",
 ;;            "dataStoreName": "cofax",
 ;;            "dataStoreDriver": "com.microsoft.jdbc.sqlserver.SQLServerDriver",
 ;;            "dataStoreUrl": "jdbc:microsoft:sqlserver://LOCALHOST:1433;DatabaseName=goon",
 ;;            "dataStoreUser": "sa",
 ;;            "dataStorePassword": "dataStoreTestQuery",
 ;;            "dataStoreTestQuery": "SET NOCOUNT ON;select test='test';",
 ;;            "dataStoreLogFile": "/usr/local/tomcat/logs/datastore.log",
 ;;            "dataStoreInitConns": 10,
 ;;            "dataStoreMaxConns": 100,
 ;;            "dataStoreConnUsageLimit": 100,
 ;;            "dataStoreLogLevel": "debug",
 ;;            "maxUrlLength": 500}},
 ;;        {
 ;;          "servlet-name": "cofaxEmail",
 ;;          "servlet-class": "org.cofax.cds.EmailServlet",
 ;;          "init-param": {
 ;;          "mailHost": "mail1",
 ;;          "mailHostOverride": "mail2"}},
 ;;        {
 ;;          "servlet-name": "cofaxAdmin",
 ;;          "servlet-class": "org.cofax.cds.AdminServlet"},
 ;;     
 ;;        {
 ;;          "servlet-name": "fileServlet",
 ;;          "servlet-class": "org.cofax.cds.FileServlet"},
 ;;        {
 ;;          "servlet-name": "cofaxTools",
 ;;          "servlet-class": "org.cofax.cms.CofaxToolsServlet",
 ;;          "init-param": {
 ;;            "templatePath": "toolstemplates/",
 ;;            "log": 1,
 ;;            "logLocation": "/usr/local/tomcat/logs/CofaxTools.log",
 ;;            "logMaxSize": "",
 ;;            "dataLog": 1,
 ;;            "dataLogLocation": "/usr/local/tomcat/logs/dataLog.log",
 ;;            "dataLogMaxSize": "",
 ;;            "removePageCache": "/content/admin/remove?cache=pages&id=",
 ;;            "removeTemplateCache": "/content/admin/remove?cache=templates&id=",
 ;;            "fileTransferFolder": "/usr/local/tomcat/webapps/content/fileTransferFolder",
 ;;            "lookInContext": 1,
 ;;            "adminGroupID": 4,
 ;;            "betaServer": true}}],
 ;;      "servlet-mapping": {
 ;;        "cofaxCDS": "/",
 ;;        "cofaxEmail": "/cofaxutil/aemail/*",
 ;;        "cofaxAdmin": "/admin/*",
 ;;        "fileServlet": "/static/*",
 ;;        "cofaxTools": "/tools/*"},
 ;;     
 ;;      "taglib": {
 ;;        "taglib-uri": "cofax.tld",
 ;;        "taglib-location": "/WEB-INF/tlds/cofax.tld"}}}
 ;;#####
 ;
SAM5 ;    
 ;;    {"menu": {
 ;;        "header": "SVG Viewer",
 ;;        "items": [
 ;;            {"id": "Open"},
 ;;            {"id": "OpenNew", "label": "Open New"},
 ;;            null,
 ;;            {"id": "ZoomIn", "label": "Zoom In"},
 ;;            {"id": "ZoomOut", "label": "Zoom Out"},
 ;;            {"id": "OriginalView", "label": "Original View"},
 ;;            null,
 ;;            {"id": "Quality"},
 ;;            {"id": "Pause"},
 ;;            {"id": "Mute"},
 ;;            null,
 ;;            {"id": "Find", "label": "Find..."},
 ;;            {"id": "FindAgain", "label": "Find Again"},
 ;;            {"id": "Copy"},
 ;;            {"id": "CopyAgain", "label": "Copy Again"},
 ;;            {"id": "CopySVG", "label": "Copy SVG"},
 ;;            {"id": "ViewSVG", "label": "View SVG"},
 ;;            {"id": "ViewSource", "label": "View Source"},
 ;;            {"id": "SaveAs", "label": "Save As"},
 ;;            null,
 ;;            {"id": "Help"},
 ;;            {"id": "About", "label": "About Adobe CVG Viewer..."}
 ;;        ]
 ;;    }}
 ;;#####
PSNUM ; Psudo-neumeric tests
 ;;{
 ;;"0.85,0.01":{"AUDIT":"TEST1","AUDIT CONDITION":"TEST2"},
 ;;"0.85,0.02":{"AUDIT":"TEST3","AUDIT CONDITION":"TEST4"},
 ;;"0.85,0.03":{"AUDIT":"TEST5","AUDIT CONDITION":"TEST6"}
 ;;}
 ;;#####

VPRJTJE
VPRJTJE ;SLC/KCM -- Unit tests for JSON encoding
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 D EN^XTMUNIT($T(+0),1) ; Run Unit Tests
 QUIT
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D CHKEQ^XTMUNIT(EXPECT,ACTUAL)
 Q
 ;
JSONESC ;; @TEST create JSON escaped string
 N X
 S X=$$ESC^VPRJSON("String with \ in the middle")
 D ASSERT("String with \\ in the middle",X)
 S X=$$ESC^VPRJSON("\ is the first character of this string")
 D ASSERT("\\ is the first character of this string",X)
 S X=$$ESC^VPRJSON("The last character of this string is \")
 D ASSERT("The last character of this string is \\",X)
 S X=$$ESC^VPRJSON("\one\two\three\")
 D ASSERT("\\one\\two\\three\\",X)
 S X=$$ESC^VPRJSON("A vee shape: \/"_$C(9)_"TABBED"_$C(9)_"and line endings."_$C(10,13,12))
 D ASSERT("A vee shape: \\\/\tTABBED\tand line endings.\n\r\f",X)
 S X=$$ESC^VPRJSON("""This text is quoted""")
 D ASSERT("\""This text is quoted\""",X)
 Q
BASIC ;; @TEST encode basic object as JSON
 N X,JSON
 S X("myObj","booleanT")="true"
 S X("myObj","booleanF")="false"
 S X("myObj","numeric")=3.1416
 S X("myObj","nullValue")="null"
 S X("myObj","array",1)="one"
 S X("myObj","array",2)="two"
 S X("myObj","array",3)="three"
 S X("myObj","subObject","fieldA")="hello"
 S X("myObj","subObject","fieldB")="world"
 D ENCODE^VPRJSON("X","JSON")
 D ASSERT($$TARGET("BASIC"),JSON(1))
 Q
VALS ;; @TEST encode simple values only object as JSON
 N X,JSON
 S X("prop1")="property1"
 S X("bool1")="true"
 S X("num1")="2.1e3"
 S X("arr",1)="apple"
 S X("arr",2)="orange"
 S X("arr",3)="pear"
 S X("arr",4,"obj")="4th array item is object"
 D ENCODE^VPRJSON("X","JSON")
 D ASSERT($$TARGET("VALS"),JSON(1))
 Q
LONG ;; @TEST encode object with continuation nodes for value
 N X,I,JSON,FILLER,TARGET
 S FILLER=", this will extend the line out to at least 78 characters."_$C(10)
 S X("title")="My note test title"
 S X("note")="This is the first line of the note.  Here are ""quotes"" and a \ and a /."_$C(10)
 F I=1:1:60 S X("note","\",I)="Additional Line #"_I_FILLER
 D ENCODE^VPRJSON("X","JSON")
 S TARGET=$$TARGET("LONG")
 D ASSERT(TARGET,$E(JSON(1),1,$L(TARGET)))
 D ASSERT(1,$D(JSON(2)))
 D ASSERT(0,$D(JSON(3)))
 S TARGET="s.\n"",""title"":""My note test title""}"
 D ASSERT(TARGET,$E(JSON(2),$L(JSON(2))-$L(TARGET)+1,$L(JSON(2))))
 Q
PRE ;; @TEST encode object where parts are already JSON encoded
 N X,JSON,TARGET
 S X("count")=3
 S X("menu",1,":",1)=$$TARGET("NODES",1)
 S X("menu",2,":",1)=$$TARGET("NODES",2)
 S X("menu",3,":",1)=$$TARGET("NODES",3)
 S X("template",":")=$$TARGET("NODES",4)
 D ENCODE^VPRJSON("X","JSON")
 S TARGET=$$TARGET("PRE",1)_$$TARGET("PRE",2)
 D ASSERT(TARGET,JSON(1))
 Q
WP ;; @TEST word processing nodes inside object
 N Y,JSON,TARGET
 D BUILDY("WP")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("WPOUT")_$$TARGET("WPOUT",2)_$$TARGET("WPOUT",3)
 D ASSERT(TARGET,JSON(1))
 Q
LTZERO ;; @TEST leading / trailing zeros get preserved
 N Y,JSON,TARGET
 S Y("count")=737
 S Y("ssn")="000427930"
 S Y("icd")="626.00"
 S Y("price")=".65"
 S Y("errors")=0
 D ENCODE^VPRJSON("Y","JSON")
 D ASSERT($$TARGET("LTZERO"),JSON(1))
 ;W !,"Y ---",! ZW Y W !,"JSON ---",! W JSON(1)
 Q
STRINGS ;; @TEST force encoding as string
 N Y,JSON,TARGET,ERR
 S Y("count")=234567
 S Y("hl7Time")="20120919"
 S Y("hl7Time","\s")=""
 S Y("icd")="722.10"
 S Y("name")="Duck,Donald"
 D ENCODE^VPRJSON("Y","JSON","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT($$TARGET("STRINGS"),JSON(1))
 Q
 ;
QUOTE ;; @TEST - quotes in subject are properly escaped.
 N Y,JSON,TARGET,ERR
 S Y("DDOUT(""0.85,0.01"")")=1
 D ENCODE^VPRJSON("Y","JSON","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT($$TARGET("QUOTE"),JSON(1))
 QUIT
 ;
EXAMPLE ;; @TEST encode samples that are on JSON.ORG
 N Y,JSON,TARGET
 D BUILDY("EX1IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX1OUT")
 D ASSERT(TARGET,JSON(1))
 D BUILDY("EX2IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX2OUT")_$$TARGET("EX2OUT",2)
 D ASSERT(TARGET,JSON(1))
 D BUILDY("EX3IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX3OUT")_$$TARGET("EX3OUT",2)
 D ASSERT(TARGET,JSON(1))
 D BUILDY("EX4IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX4OUT")
 D ASSERT(TARGET,$E(JSON(1),1,215))
 D ASSERT(2758,$L(JSON(1)))
 Q
BUILDY(LABEL) ; build Y array based on LABEL
 ; expects Y from EXAMPLE
 N I,X
 K Y
 F I=1:1 S X=$P($T(@LABEL+I^VPRJTJED),";;",2,999) Q:X="zzzzz"  X "S "_X
 Q
TARGET(ID,OFFSET) ; values to test against
 S OFFSET=$G(OFFSET,1)
 Q $P($T(@ID+OFFSET^VPRJTJED),";;",2,999)

VPRJTJED
VPRJTJED ;SLC/KCM -- Data for JSON encoding unit tests
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;
 ; expected return data values
 ;
BASIC ;; Basic object 
 ;;{"myObj":{"array":["one","two","three"],"booleanF":false,"booleanT":true,"nullValue":null,"numeric":3.1416,"subObject":{"fieldA":"hello","fieldB":"world"}}}
VALS ;; Simple values only object
 ;;{"arr":["apple","orange","pear",{"obj":"4th array item is object"}],"bool1":true,"num1":2.1e3,"prop1":"property1"}
LONG ;; Object with continuation nodes
 ;;{"note":"This is the first line of the note.  Here are \"quotes\" and a \\ and a \/.\nAdditional Line #1, this will extend the line out to at least 78 characters.\nAdditional Line #2,
NODES ;; Nodes preformatted as JSON
 ;;{"value": "New", "onclick": "CreateNewDoc()"}
 ;;{"value": "Open", "onclick": "OpenDoc()"}
 ;;{"value": "Close", "onclick": "CloseDoc()"}
 ;;{"data":"Click Here","size":36,"style":"bold","name":"text1","hOffset":250,"vOffset":100,"alignment":"center","onMouseUp":"sun1.opacity = (sun1.opacity / 100) * 90;"}
PRE ;; Adding already encoded values to object
 ;;{"count":3,"menu":[{"value": "New", "onclick": "CreateNewDoc()"},{"value": "Open", "onclick": "OpenDoc()"},{"value": "Close", "onclick": "CloseDoc()"}],"template":
 ;;{"data":"Click Here","size":36,"style":"bold","name":"text1","hOffset":250,"vOffset":100,"alignment":"center","onMouseUp":"sun1.opacity = (sun1.opacity / 100) * 90;"}}
WPOUT ;; WP field encoded as JSON
 ;;{"dob":"APR 7,1935","gender":"MALE","lastVitals":{"height":{"lastDone":"Aug 24, 2009","value":190},"weight":{"lastDone":"Jul 01, 2011","value":210}},"name":"AVIVAPATIENT,THIRTY","patDemDetails":{"text":"               COORDINATING
 ;; MASTER OF RECORD: ABILENE (CAA)\r\n Address: Any Street                    Temporary: NO TEMPORARY ADDRESS\r\n         Any Town,WV 99998-0071\r\n         \r\n  County: UNSPECIFIED                     From\/To: NOT APPLICABLE\r\n"},
 ;;"uid":"urn:va:patient:F484:8"}
LTZERO ;; Leading and trailing zeros
 ;;{"count":737,"errors":0,"icd":"626.00","price":".65","ssn":"000427930"}
STRINGS ;; strings that look like numbers
 ;;{"count":234567,"hl7Time":"20120919","icd":"722.10","name":"Duck,Donald"}
QUOTE ;; Quoted subjects test
 ;;{"DDOUT(\"0.85,0.01\")":1}
EX1OUT ;; JSON.org example #1 target
 ;;{"menu":{"id":"file","popup":{"menuitem":[{"onclick":"CreateNewDoc()","value":"New"},{"onclick":"OpenDoc()","value":"Open"},{"onclick":"CloseDoc()","value":"Close"}]},"value":"File"}}
EX2OUT ;; JSON.org example #2 target
 ;;{"glossary":{"GlossDiv":{"GlossList":{"GlossEntry":{"Abbrev":"ISO 8879:1986","Acronym":"SGML","GlossDef":{"GlossSeeAlso":["GML","XML"],"para":"A meta-markup language, used to create markup languages such as DocBook."}
 ;;,"GlossSee":"markup","GlossTerm":"Standard Generalized Markup Language","ID":"SGML","SortAs":"SGML"}},"title":"S"},"title":"example glossary"}}
EX3OUT ;; JSON.org example #3 target
 ;;{"widget":{"debug":"on","image":{"alignment":"center","hOffset":250,"name":"sun1","src":"Images\/Sun.png","vOffset":250},"text":{"alignment":"center","data":"Click Here","hOffset":250,"name":"text1","onMouseUp":
 ;;"sun1.opacity = (sun1.opacity \/ 100) * 90;","size":36,"style":"bold","vOffset":100},"window":{"height":500,"name":"main_window","title":"Sample Konfabulator Widget","width":500}}}
EX4OUT ;; JSON.org example #4 target
 ;;{"web-app":{"servlet":[{"init-param":{"cachePackageTagsRefresh":60,"cachePackageTagsStore":200,"cachePackageTagsTrack":200,"cachePagesDirtyRead":10,"cachePagesRefresh":10,"cachePagesStore":100,"cachePagesTrack":200,
 ;
 ; data values to test long text field input
 ;
WP ;; object with word processing field
 ;;Y("dob")="APR 7,1935"
 ;;Y("gender")="MALE"
 ;;Y("lastVitals","height","lastDone")="Aug 24, 2009"
 ;;Y("lastVitals","height","value")=190
 ;;Y("lastVitals","weight","lastDone")="Jul 01, 2011"
 ;;Y("lastVitals","weight","value")=210
 ;;Y("name")="AVIVAPATIENT,THIRTY"
 ;;Y("patDemDetails","text","\",6)="               COORDINATING MASTER OF RECORD: ABILENE (CAA)"_$C(13,10)
 ;;Y("patDemDetails","text","\",7)=" Address: Any Street                    Temporary: NO TEMPORARY ADDRESS"_$C(13,10)
 ;;Y("patDemDetails","text","\",8)="         Any Town,WV 99998-0071"_$C(13,10)
 ;;Y("patDemDetails","text","\",9)="         "_$C(13,10)
 ;;Y("patDemDetails","text","\",10)="  County: UNSPECIFIED                     From/To: NOT APPLICABLE"_$C(13,10)
 ;;Y("uid")="urn:va:patient:F484:8"
 ;;zzzzz
 ;
 ; data values for JSON.ORG examples rendered as M arrays
 ;
EX1IN ;; JSON.org example #1
 ;;Y("menu","id")="file"
 ;;Y("menu","popup","menuitem",1,"onclick")="CreateNewDoc()"
 ;;Y("menu","popup","menuitem",1,"value")="New"
 ;;Y("menu","popup","menuitem",2,"onclick")="OpenDoc()"
 ;;Y("menu","popup","menuitem",2,"value")="Open"
 ;;Y("menu","popup","menuitem",3,"onclick")="CloseDoc()"
 ;;Y("menu","popup","menuitem",3,"value")="Close"
 ;;Y("menu","value")="File"
 ;;zzzzz
EX2IN ;; JSON.org example #2
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","Abbrev")="ISO 8879:1986"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","Acronym")="SGML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",1)="GML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",2)="XML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","para")="A meta-markup language, used to create markup languages such as DocBook."
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossSee")="markup"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossTerm")="Standard Generalized Markup Language"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","ID")="SGML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","SortAs")="SGML"
 ;;Y("glossary","GlossDiv","title")="S"
 ;;Y("glossary","title")="example glossary"
 ;;zzzzz
EX3IN ;; JSON.org example #3
 ;;Y("widget","debug")="on"
 ;;Y("widget","image","alignment")="center"
 ;;Y("widget","image","hOffset")=250
 ;;Y("widget","image","name")="sun1"
 ;;Y("widget","image","src")="Images/Sun.png"
 ;;Y("widget","image","vOffset")=250
 ;;Y("widget","text","alignment")="center"
 ;;Y("widget","text","data")="Click Here"
 ;;Y("widget","text","hOffset")=250
 ;;Y("widget","text","name")="text1"
 ;;Y("widget","text","onMouseUp")="sun1.opacity = (sun1.opacity / 100) * 90;"
 ;;Y("widget","text","size")=36
 ;;Y("widget","text","style")="bold"
 ;;Y("widget","text","vOffset")=100
 ;;Y("widget","window","height")=500
 ;;Y("widget","window","name")="main_window"
 ;;Y("widget","window","title")="Sample Konfabulator Widget"
 ;;Y("widget","window","width")=500
 ;;zzzzz
EX4IN ;; JSON.org example #4
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsRefresh")=60
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsStore")=200
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsTrack")=200
 ;;Y("web-app","servlet",1,"init-param","cachePagesDirtyRead")=10
 ;;Y("web-app","servlet",1,"init-param","cachePagesRefresh")=10
 ;;Y("web-app","servlet",1,"init-param","cachePagesStore")=100
 ;;Y("web-app","servlet",1,"init-param","cachePagesTrack")=200
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesRefresh")=15
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesStore")=50
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesTrack")=100
 ;;Y("web-app","servlet",1,"init-param","configGlossary:adminEmail")="ksm@pobox.com"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:installationAt")="Philadelphia, PA"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:poweredBy")="Cofax"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:poweredByIcon")="/images/cofax.gif"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:staticPath")="/content/static"
 ;;Y("web-app","servlet",1,"init-param","dataStoreClass")="org.cofax.SqlDataStore"
 ;;Y("web-app","servlet",1,"init-param","dataStoreConnUsageLimit")=100
 ;;Y("web-app","servlet",1,"init-param","dataStoreDriver")="com.microsoft.jdbc.sqlserver.SQLServerDriver"
 ;;Y("web-app","servlet",1,"init-param","dataStoreInitConns")=10
 ;;Y("web-app","servlet",1,"init-param","dataStoreLogFile")="/usr/local/tomcat/logs/datastore.log"
 ;;Y("web-app","servlet",1,"init-param","dataStoreLogLevel")="debug"
 ;;Y("web-app","servlet",1,"init-param","dataStoreMaxConns")=100
 ;;Y("web-app","servlet",1,"init-param","dataStoreName")="cofax"
 ;;Y("web-app","servlet",1,"init-param","dataStorePassword")="dataStoreTestQuery"
 ;;Y("web-app","servlet",1,"init-param","dataStoreTestQuery")="SET NOCOUNT ON;select test='test';"
 ;;Y("web-app","servlet",1,"init-param","dataStoreUrl")="jdbc:microsoft:sqlserver://LOCALHOST:1433;DatabaseName=goon"
 ;;Y("web-app","servlet",1,"init-param","dataStoreUser")="sa"
 ;;Y("web-app","servlet",1,"init-param","defaultFileTemplate")="articleTemplate.htm"
 ;;Y("web-app","servlet",1,"init-param","defaultListTemplate")="listTemplate.htm"
 ;;Y("web-app","servlet",1,"init-param","jspFileTemplate")="articleTemplate.jsp"
 ;;Y("web-app","servlet",1,"init-param","jspListTemplate")="listTemplate.jsp"
 ;;Y("web-app","servlet",1,"init-param","maxUrlLength")=500
 ;;Y("web-app","servlet",1,"init-param","redirectionClass")="org.cofax.SqlRedirection"
 ;;Y("web-app","servlet",1,"init-param","searchEngineFileTemplate")="forSearchEngines.htm"
 ;;Y("web-app","servlet",1,"init-param","searchEngineListTemplate")="forSearchEnginesList.htm"
 ;;Y("web-app","servlet",1,"init-param","searchEngineRobotsDb")="WEB-INF/robots.db"
 ;;Y("web-app","servlet",1,"init-param","templateLoaderClass")="org.cofax.FilesTemplateLoader"
 ;;Y("web-app","servlet",1,"init-param","templateOverridePath")=""
 ;;Y("web-app","servlet",1,"init-param","templatePath")="templates"
 ;;Y("web-app","servlet",1,"init-param","templateProcessorClass")="org.cofax.WysiwygTemplate"
 ;;Y("web-app","servlet",1,"init-param","useDataStore")="true"
 ;;Y("web-app","servlet",1,"init-param","useJSP")="false"
 ;;Y("web-app","servlet",1,"servlet-class")="org.cofax.cds.CDSServlet"
 ;;Y("web-app","servlet",1,"servlet-name")="cofaxCDS"
 ;;Y("web-app","servlet",2,"init-param","mailHost")="mail1"
 ;;Y("web-app","servlet",2,"init-param","mailHostOverride")="mail2"
 ;;Y("web-app","servlet",2,"servlet-class")="org.cofax.cds.EmailServlet"
 ;;Y("web-app","servlet",2,"servlet-name")="cofaxEmail"
 ;;Y("web-app","servlet",3,"servlet-class")="org.cofax.cds.AdminServlet"
 ;;Y("web-app","servlet",3,"servlet-name")="cofaxAdmin"
 ;;Y("web-app","servlet",4,"servlet-class")="org.cofax.cds.FileServlet"
 ;;Y("web-app","servlet",4,"servlet-name")="fileServlet"
 ;;Y("web-app","servlet",5,"init-param","adminGroupID")=4
 ;;Y("web-app","servlet",5,"init-param","betaServer")="true"
 ;;Y("web-app","servlet",5,"init-param","dataLog")=1
 ;;Y("web-app","servlet",5,"init-param","dataLogLocation")="/usr/local/tomcat/logs/dataLog.log"
 ;;Y("web-app","servlet",5,"init-param","dataLogMaxSize")=""
 ;;Y("web-app","servlet",5,"init-param","fileTransferFolder")="/usr/local/tomcat/webapps/content/fileTransferFolder"
 ;;Y("web-app","servlet",5,"init-param","log")=1
 ;;Y("web-app","servlet",5,"init-param","logLocation")="/usr/local/tomcat/logs/CofaxTools.log"
 ;;Y("web-app","servlet",5,"init-param","logMaxSize")=""
 ;;Y("web-app","servlet",5,"init-param","lookInContext")=1
 ;;Y("web-app","servlet",5,"init-param","removePageCache")="/content/admin/remove?cache=pages&id="
 ;;Y("web-app","servlet",5,"init-param","removeTemplateCache")="/content/admin/remove?cache=templates&id="
 ;;Y("web-app","servlet",5,"init-param","templatePath")="toolstemplates/"
 ;;Y("web-app","servlet",5,"servlet-class")="org.cofax.cms.CofaxToolsServlet"
 ;;Y("web-app","servlet",5,"servlet-name")="cofaxTools"
 ;;Y("web-app","servlet-mapping","cofaxAdmin")="/admin/*"
 ;;Y("web-app","servlet-mapping","cofaxCDS")="/"
 ;;Y("web-app","servlet-mapping","cofaxEmail")="/cofaxutil/aemail/*"
 ;;Y("web-app","servlet-mapping","cofaxTools")="/tools/*"
 ;;Y("web-app","servlet-mapping","fileServlet")="/static/*"
 ;;Y("web-app","taglib","taglib-location")="/WEB-INF/tlds/cofax.tld"
 ;;Y("web-app","taglib","taglib-uri")="cofax.tld"
 ;;zzzzz

XTMUNIT
XTMUNIT ;OAKLAND OIFO/JLI - MUNIT UNIT TESTING FOR M ROUTINES ;2013-11-27  1:56 PM
        ;;7.3;TOOLKIT;**81**;Apr 25, 1995;Build 24
    ;
    ; Original by Dr. Joel Ivey
    ; Contributions by Dr. Sam Habiel
    ; 
        ; 100622 JLI - corrected typo in comments where XTMUINPT was listed as XTMUINP
        ; 100622 JLI - removed a comment which indicated data could potentially be returned from the called routine
        ;              in the XTMUINPT array.
        ; 100622 JLI - added code to handle STARTUP and SHUTDOWN from GUI app
        ; 110719 JLI - modified separators in GUI handling from ^ to ~~^~~
        ;              in the variable XTGUISEP if using a newer version of the
        ;              GUI app (otherwise, it is simply set to ^) since results
        ;              with a series of ^ embedded disturbed the output reported
        ; 130726 SMH - Fixed SETUP and TEARDOWN so that they run before/after each
        ;              test rather than once. General refactoring.
    ; 130726 SMH - SETUT initialized IO in case it's not there to $P. Inits vars
    ;              using DT^DICRW.
    ; 131217 SMH - Change call in SETUP to S U="^" instead of DT^DICRW
    ; 131218 SMH - Any checks to $ZE will also check $ZS for GT.M.
    ; 131218 SMH - Remove calls to %ZISUTL to manage devices to prevent dependence on VISTA.
    ;              Use XTMUNIT("DEV","OLD") for old devices
        Q
        ;
EN(XTMURNAM,XTMUVERB)   ; .SR Entry point with primary test routine name, optional 1 for verbose output
        N XTMULIST,XTMUROU,XTMUNIT
        I $G(XTMUVERB)'=1 S XTMUVERB=0
        S XTMULIST=1,XTMUROU(XTMULIST)=XTMURNAM
        D SETUT
        D EN1(.XTMUROU,XTMULIST)
        Q
        ;
SETUT   ;
        ; VEN/SMH 26JUL2013
        I '$D(IO) S IO=$P
    S U="^"
        ; VEN/SMH 26JUL2013 END
        ;
        ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
        S XTMUNIT("IO")=IO,XTMUNIT("DEV")="",XTMUNIT("DEVN")="" F  S XTMUNIT("DEVN")=$O(^TMP("XUDEVICE",$J,XTMUNIT("DEVN"))) Q:XTMUNIT("DEVN")=""  I $G(^(XTMUNIT("DEVN"),"IO"))=IO S XTMUNIT("DEV")=^(0) Q
        I XTMUNIT("DEV")="" S XTMUNIT("DEV")="XTMUNIT DEVICE"
        S XTMUNIT=1 ; set to identify unit test being run check with $$ISUTEST^XTMUNIT()
        Q
        ;
EN1(XTMUROU,XTMULIST)   ;
        ; VEN/SMH 26JUL2013 - This block is refactored to fix problems with 
        ; SETUP and TEARDOWN not happening at the right time
        N XTMUERRL,XTMUK,XTMUI,XTMUJ,OLDIO,OLDIOFLG,OLDIONAM,XTMUSTRT
        ; ZEXCEPT: XTMUVERB   -- ARGUMENT TO EN
        ; ZEXCEPT: XTMUGUI      -- CONDITIONALLY DEFINED BY GUINEXT
        ; ZEXCEPT: XTMUNIT  -- NEWED IN EN
        ;
        ; Structure map for XTMUNIT
        ; -- CURR = Counter for routine number. Used as sub in XTMUROU
        ; -- ECNT = Entry point count in loop (cf. NERT); VEN/SMH - Needed?
        ; -- FAIL = Number of failures
        ; -- CHK  = Number of checks ran (TF/EQ/FAIL)
        ; -- NENT = Number of entry points ran
        ; -- ERRN = Number of errors
        S XTMUNIT("CURR")=0,XTMUNIT("ECNT")=0,XTMUNIT("FAIL")=0,XTMUNIT("CHK")=0,XTMUNIT("NENT")=0,XTMUNIT("ERRN")=0
        ;
        ; -- GET LIST OF ROUTINES --
        ; first get any tree of routines from this one
        D GETTREE^XTMUNIT1(.XTMUROU,.XTMULIST)
        ;
        ; -- STARTUP --
        ; 070224 - following code added to allow one overall STARTUP code JLI
        F  S XTMUNIT("CURR")=XTMUNIT("CURR")+1 Q:'$D(XTMUROU(XTMUNIT("CURR")))  D  I $G(XTMUSTRT)'="" D @XTMUSTRT Q
        . I $T(@("STARTUP^"_XTMUROU(XTMUNIT("CURR"))))'="" S XTMUSTRT="STARTUP^"_XTMUROU(XTMUNIT("CURR"))
        . Q
        ; 070224 - end of addition JLI
        ;
        ;
        ; Now process each routine that has been referenced
        S XTMUNIT("CURR")=0
        F  S XTMUNIT("CURR")=XTMUNIT("CURR")+1 Q:'$D(XTMUROU(XTMUNIT("CURR")))  D
        . N XTMUETRY ; Test list to run
        . ; 
        . ; Collect Test list.
        . D CHEKTEST^XTMUNIT1(XTMUROU(XTMUNIT("CURR")),.XTMUNIT,.XTMUETRY)
        . ;
        . ; if a SETUP entry point exists, save it off in XTMUNIT
        . N XTMSETUP S XTMSETUP="SETUP^"_XTMUROU(XTMUNIT("CURR"))
        . S XTMUNIT("LINE")=$T(@XTMSETUP) I XTMUNIT("LINE")'="" S XTMUNIT("SETUP")=XTMSETUP
        . K XTMSETUP ; we're done!
        . ;
        . ; if a TEARDOWN entry point exists, ditto
        . N XTMTEARDOWN S XTMTEARDOWN="TEARDOWN^"_XTMUROU(XTMUNIT("CURR"))
        . S XTMUNIT("LINE")=$T(@XTMTEARDOWN) I XTMUNIT("LINE")'="" S XTMUNIT("TEARDOWN")=XTMTEARDOWN
        . K XTMTEARDOWN ; done here.
        . ;
        . ; VEN/SMH 26JUL2013 - this block changed to correct running of setup and teardown
        . ; run each of the specified entry points
        . ;
        . ; == THIS FOR/DO BLOCK IS THE CENTRAL TEST RUNNER ==
        . S XTMUI=0
        . F  S XTMUI=$O(XTMUETRY(XTMUI)) Q:XTMUI'>0  S XTMUNIT("ENUM")=XTMUNIT("ERRN")+XTMUNIT("FAIL") D  I XTMUVERB,'$D(XTMUGUI),XTMUNIT("ENUM")=(XTMUNIT("ERRN")+XTMUNIT("FAIL")) D VERBOSE(.XTMUETRY,XTMUI)
        . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
        . . ; 
        . . ; Run Set-up Code (only if present)
        . . S XTMUNIT("ENT")=$G(XTMUNIT("SETUP")) ; Current entry
        . . S XTMUNIT("NAME")="Set-up Code"
        . . D:XTMUNIT("ENT")]"" @XTMUNIT("ENT")
        . . ;
        . . ; Run actual test
        . . S XTMUNIT("ECNT")=XTMUNIT("ECNT")+1
        . . S XTMUNIT("NAME")=XTMUETRY(XTMUI,"NAME")
        . . S XTMUNIT("ENT")=XTMUETRY(XTMUI)_"^"_XTMUROU(XTMUNIT("CURR"))
        . . D @XTMUNIT("ENT")
        . . ;
        . . ; Run Teardown Code (only if present)
        . . S XTMUNIT("ENT")=$G(XTMUNIT("TEARDOWN"))
        . . S XTMUNIT("NAME")="Teardown Code"
        . . D:XTMUNIT("ENT")]"" @XTMUNIT("ENT")
        . ;
        . ;
        . ; keep a XTMUCNT of number of entry points executed across all routines
        . S XTMUNIT("NENT")=XTMUNIT("NENT")+XTMUNIT("ENTN")
        . Q
        ;
        ; -- SHUTDOWN --
        ; 070224 - following code added to allow one overall SHUTDOWN code JLI
        N XTFINISH
        S XTMUNIT("CURR")=0
        F  S XTMUNIT("CURR")=XTMUNIT("CURR")+1 Q:'$D(XTMUROU(XTMUNIT("CURR")))  D  I $G(XTFINISH)'="" D @XTFINISH Q
        . I $T(@("SHUTDOWN^"_XTMUROU(XTMUNIT("CURR"))))'="" S XTFINISH="SHUTDOWN^"_XTMUROU(XTMUNIT("CURR"))
        . Q
        ; 070224 - End of addition JLI
        ;
        S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
        I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
        W !!,"Ran ",XTMULIST," Routine",$S(XTMULIST>1:"s",1:""),", ",XTMUNIT("NENT")," Entry Tag",$S(XTMUNIT("NENT")>1:"s",1:"")
        W !,"Checked ",XTMUNIT("CHK")," test",$S(XTMUNIT("CHK")>1:"s",1:""),", with ",XTMUNIT("FAIL")," failure",$S(XTMUNIT("FAIL")'=1:"s",1:"")," and encountered ",XTMUNIT("ERRN")," error",$S(XTMUNIT("ERRN")'=1:"s",1:""),"."
        I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
        Q
        ; -- end EN1
VERBOSE(XTMUETRY,XTMUI) ;
        N OLDIO,OLDIOFLG,OLDIONAM
        ; ZEXCEPT: XTMUNIT - NEWED IN EN
        S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
        I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
        W !,"OK - ",XTMUETRY(XTMUI) I $G(XTMUETRY(XTMUI,"NAME"))'="" W " - ",XTMUETRY(XTMUI,"NAME")
        IF OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
        Q
        ;
CHKTF(XTSTVAL,XTERMSG)  ; Entry point for checking True or False values
        N OLDIO,OLDIOFLG,OLDIONAM
        ; ZEXCEPT: XTMUERRL,XTMUGUI - CREATED IN SETUP, KILLED IN END
        ; ZEXCEPT: XTMUNIT - NEWED IN EN
        I $G(XTSTVAL)="" D NVLDARG Q
        I $G(XTERMSG)="" S XTERMSG="no failure message provided"
        S XTMUNIT("CHK")=$G(XTMUNIT("CHK"))+1
        I '$D(XTMUGUI) D
        . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
        . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
        . I 'XTSTVAL W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " D
        . . W XTERMSG,! S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
        . . Q
        . E  W "."
        . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
        . Q
        I $D(XTMUGUI),'XTSTVAL S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG
        Q
        ;
CHKEQ(XTEXPECT,XTACTUAL,XTERMSG)        ; Entry point for checking values to see if they are EQUAL
        N FAILMSG,OLDIO,OLDIOFLG,OLDIONAM
        ; ZEXCEPT: XTMUERRL,XTMUGUI -CREATED IN SETUP, KILLED IN END
        ; ZEXCEPT: XTMUNIT  -- NEWED IN EN
        I '$D(XTEXPECT),'$D(XTACTUAL) D NVLDARG Q
        S XTACTUAL=$G(XTACTUAL),XTEXPECT=$G(XTEXPECT)
        I $G(XTERMSG)="" S XTERMSG="no failure message provided"
        S XTMUNIT("CHK")=XTMUNIT("CHK")+1
        I XTEXPECT'=XTACTUAL S FAILMSG="<"_XTEXPECT_"> vs <"_XTACTUAL_"> - "
        I '$D(XTMUGUI) D
        . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
        . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
        . I XTEXPECT'=XTACTUAL W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " W FAILMSG,XTERMSG,! D
        . . S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
        . . Q
        . E  W "."
        . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
        . Q
        I $D(XTMUGUI),XTEXPECT'=XTACTUAL S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_FAILMSG_XTERMSG
        Q
        ;
FAIL(XTERMSG)   ; Entry point for generating a failure message
        N OLDIO,OLDIOFLG,OLDIONAM
        ; ZEXCEPT: XTMUERRL,XTMUGUI -CREATED IN SETUP, KILLED IN END
        ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
        I $G(XTERMSG)="" S XTERMSG="no failure message provided"
        S XTMUNIT("CHK")=XTMUNIT("CHK")+1
        I '$D(XTMUGUI) D
        . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
        . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
        . W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " W XTERMSG,! D
        . . S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
        . . Q
        . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
        . Q
        I $D(XTMUGUI) S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG
        Q
        ;
CHKLEAKS(XTMUCODE,XTMULOC,XTMUINPT)     ; functionality to check for variable leaks on executing a section of code
        ; XTMUCODE - A string that specifies the code that is to be XECUTED and checked for leaks.
        ;            this should be a complete piece of code (e.g., "S X=$$NEW^XLFDT()" or "D EN^XTMUNIT(""ROUNAME"")")
        ; XTMULOC  - A string that is used to indicate the code tested for variable leaks
        ; XTMUINPT - An optional variable which may be passed by reference.  This may
        ;           be used to pass any variable values, etc. into the code to be
        ;           XECUTED.  In this case, set the subscript to the variable name and the
        ;           value of the subscripted variable to the desired value of the subscript.
        ;              e.g., (using NAME as my current namespace)
        ;                   S CODE="S XTMUINPT=$$ENTRY^ROUTINE(ZZVALUE1,ZZVALUE2)"
        ;                   S NAMELOC="ENTRY^ROUTINE leak test"   (or simply "ENTRY^ROUTINE")
        ;                   S NAMEINPT("ZZVALUE1")=ZZVALUE1
        ;                   S NAMEINPT("ZZVALUE2")=ZZVALUE2
        ;                   D CHKLEAKS^XTMUNIT(CODE,NAMELOC,.NAMEINPT)
        ;
        ;           If part of a unit test, any leaked variables in ENTRY^ROUTINE which result
        ;           from running the code with the variables indicated will be shown as FAILUREs.
        ;
        ;           If called outside of a unit test, any leaked variables will be printed to the
        ;           current device.
        ;
        N (XTMUCODE,XTMULOC,XTMUINPT,DUZ,IO,U,XTMUERRL,XTMUNIT,XTMUGUI,XTMUI,XTMUJ,XTMUK,XTMULIST,XTMUROU,XTMUSTRT)
        ; ZEXCEPT: XTMUNIT - part of exclusive NEW TESTS FOR EXISTENCE ONLY
        ; ZEXCEPT: XTMUVAR - handled by exclusive NEW
        ;
        ; ACTIVATE ANY VARIABLES PASSED AS SUBSCRIPTS TO XTMUINPT TO THEIR VALUES
        S XTMUVAR=" " F  S XTMUVAR=$O(XTMUINPT(XTMUVAR)) Q:XTMUVAR=""  S (@XTMUVAR)=XTMUINPT(XTMUVAR)
        X XTMUCODE
        N ZZUTVAR S ZZUTVAR="%"
        I $G(XTMUNIT)=1 D
        . I $D(@ZZUTVAR),'$D(XTMUINPT(ZZUTVAR)) D FAIL^XTMUNIT(XTMULOC_" VARIABLE LEAK: "_ZZUTVAR)
        . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,4)'="XTMU",'$D(XTMUINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,"'[(","_ZZUTVAR_",") D FAIL^XTMUNIT(XTMULOC_" VARIABLE LEAK: "_ZZUTVAR)
        . Q
        I '($G(XTMUNIT)=1) D
        . I $D(@ZZUTVAR),'$D(XTMUINPT(ZZUTVAR)) W !,XTMULOC_" VARIABLE LEAK: "_ZZUTVAR
        . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,4)'="XTMU",'$D(XTMUINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,"'[(","_ZZUTVAR_",") W !,XTMULOC_" VARIABLE LEAK: "_ZZUTVAR
        . Q
        Q
        ;
NVLDARG ; generate message for invalid arguments to test
        N XTERMSG,OLDIO,OLDIOFLG,OLDIONAM
        ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
        ; ZEXCEPT: XTMUERRL,XTMUGUI -CREATED IN SETUP, KILLED IN END
        S XTERMSG="NO VALUES INPUT TO CHKEQ^XTMUNIT - no evaluation possible"
        I '$D(XTMUGUI) D
        . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
        . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
        . W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " W XTERMSG,! D
        . . S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
        . . Q
        . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
        . Q
        I $D(XTMUGUI) S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG
        Q
        ;
ERROR   ; record errors
        ; ZEXCEPT: XTMUERRL,XTMUGUI,XTMUERR -CREATED IN SETUP, KILLED IN END
        ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
        S XTMUNIT("CHK")=XTMUNIT("CHK")+1
        I '$D(XTMUGUI) D ERROR1
        I $D(XTMUGUI) D
        . S XTMUNIT("CNT")=XTMUNIT("CNT")+1
        . S XTMUERR=XTMUERR+1
        . S @XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_XTGUISEP_"ERROR"_XTGUISEP_$S(+$SY=47:$ZS,1:$ZE)
        . Q
        S @($S(+$SY=47:"$ZS",1:"$ZE")_"="_""""""),$EC=""
        Q
        ;
ERROR1  ;
        N OLDIO,OLDIOFLG,OLDIONAM
        ; ZEXCEPT: XTMUERRL -CREATED IN SETUP, KILLED IN END
        ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
        S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
        I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
        W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - Error: " W $S(+$SY=47:$ZS,1:$ZE),! D
        . S XTMUNIT("ERRN")=XTMUNIT("ERRN")+1,XTMUERRL(XTMUNIT("ERRN"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=$S(+$SY=47:$ZS,1:$ZE),XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
        . Q
        I IO'=OLDIO D RESETIO(OLDIOFLG,OLDIONAM)
        Q
SETIO(OLDIOFLG,OLDIONAM)        ; BOTH PASSED BY REFERENCE
        ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
        N OLDION S OLDION="" F  S OLDION=$O(^TMP("XUDEVICE",$J,OLDION)) Q:OLDION=""  I $G(^(OLDION,"IO"))=IO S OLDIONAM=^(0),OLDIOFLG=1
        ;I 'OLDIOFLG S OLDIONAM="OLD MUNIT DEV" D SAVDEV^%ZISUTL(OLDIONAM)
    I 'OLDIOFLG S XTMUNIT("DEV","OLD")=OLDIONAM
        USE XTMUNIT("DEV")
        Q
        ;
RESETIO(OLDIOFLG,OLDIONAM)      ;
        ;D USE^%ZISUTL(OLDIONAM) I 'OLDIOFLG D RMDEV^%ZISUTL(OLDIONAM)
    USE OLDIONAM I 'OLDIOFLG K XTMUNIT("DEV","OLD")
        Q
        ;
ISUTEST()       ; .SUPPORTED API TO DETERMINE IF CURRENTLY IN UNIT TEST
        ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
        Q $G(XTMUNIT)=1
        ;
PICKSET ; .OPT Interactive selection of MUnit Test Group
        N DIC,Y,XTMUROU,XTMULIST,DIR
        S DIC=8992.8,DIC(0)="AEQM" D ^DIC Q:Y'>0  W !
        D GETSET(+Y,.XTMUROU,.XTMULIST)
        N DIC,Y,XTMUNIT
        D SETUT
        D EN1(.XTMUROU,XTMULIST)
        S DIR(0)="EA",DIR("A")="Enter RETURN to continue:" D ^DIR K DIR
        Q
        ;
RUNSET(SETNAME) ; .SR Run with Specified Selection of MUnit Test Group
        N Y,XTMUROU,XTMULIST
        Q:$G(SETNAME)=""
        S Y=+$$FIND1^DIC(8992.8,"","X",SETNAME) Q:Y'>0
        D GETSET(Y,.XTMUROU,.XTMULIST)
        N Y,SETNAME,XTMUNIT
        D SETUT
        D EN1(.XTMUROU,XTMULIST)
        Q
        ;
DOSET(IEN)      ;
        N XTMUROU,XTMULIST
        S XTMULIST=0
        D GETSET($G(IEN),.XTMUROU,.XTMULIST)
        I XTMULIST>0  N IEN,XTMUNIT D SETUT,EN1(.XTMUROU,XTMULIST)
        Q
        ;
GETSET(IEN,XTMUROU,XTMULIST)    ;
        N IENS,XTMROOT
        S IENS=IEN_"," D GETS^DIQ(8992.8,IENS,"1*","","XTMROOT")
        S XTMULIST=0,IENS="" F  S IENS=$O(XTMROOT(8992.81,IENS)) Q:IENS=""  S XTMULIST=XTMULIST+1,XTMUROU(XTMULIST)=XTMROOT(8992.81,IENS,.01)
        Q
        ;
GUISET(XTMURSLT,XTSET)  ; Entry point for GUI start with selected Test Set IEN
        N XTMUROU,XTMULIST,XTMUNIT
        D SETUT
        S XTMUNIT("RSLT")=$NA(^TMP("MUNIT-XTMURSLT",$J)) K @XTMUNIT("RSLT")
        D GETSET(XTSET,.XTMUROU,.XTMULIST)
        D GETLIST(.XTMUROU,XTMULIST,XTMUNIT("RSLT"))
        S @XTMUNIT("RSLT")@(1)=(@XTMUNIT("RSLT")@(1))_"^1" ; 110719 mark as new version
        S XTMURSLT=XTMUNIT("RSLT")
        Q
        ;
GUILOAD(XTMURSLT,XTMUROUN)      ; Entry point for GUI start with XTMUROUN containing primary routine name
        N XTMUROU,XTMUNIT
        D SETUT
        S XTMUNIT("RSLT")=$NA(^TMP("MUNIT-XTMURSLT",$J)) K @XTMUNIT("RSLT")
        S XTMUROU(1)=XTMUROUN
        D GETLIST(.XTMUROU,1,XTMUNIT("RSLT"))
        S @XTMUNIT("RSLT")@(1)=(@XTMUNIT("RSLT")@(1))_"^1" ; 110719 mark as new version
        S XTMURSLT=XTMUNIT("RSLT")
        Q
        ;
GETLIST(XTMUROU,XTMULIST,XTMURSLT)      ;
        N I,XTMUROUL,XTMUROUN,XTMUNIT,XTCOMNT,XTVALUE,XTMUCNT
        S XTVALUE=$NA(^TMP("GUI-MUNIT",$J)) K @XTVALUE
        S XTMUCNT=0,XTCOMNT=""
        D GETTREE^XTMUNIT1(.XTMUROU,XTMULIST)
        F I=1:1 Q:'$D(XTMUROU(I))  S XTMUROUL(XTMUROU(I))=""
        S XTMUROUN="" F  S XTMUROUN=$O(XTMUROUL(XTMUROUN)) Q:XTMUROUN=""  D LOAD(XTMUROUN,.XTMUCNT,XTVALUE,XTCOMNT,.XTMUROUL)
        M @XTMURSLT=@XTVALUE
        K @XTMURSLT@("SHUTDOWN")
        K @XTMURSLT@("STARTUP")
        S @XTVALUE@("LASTROU")="" ; Use this to keep track of place in routines
        Q
        ;
        ; generate list of unit test routines, entry points and comments on test for entry point
LOAD(XTMUROUN,XTMUNCNT,XTVALUE,XTCOMNT,XTMUROUL)        ;
        I $T(@("^"_XTMUROUN))="" S XTMUNCNT=XTMUNCNT+1,@XTVALUE@(XTMUNCNT)=XTMUROUN_"^^*** ERROR - ROUTINE NAME NOT FOUND" Q
        S XTMUNCNT=XTMUNCNT+1,@XTVALUE@(XTMUNCNT)=XTMUROUN_U_U_XTCOMNT
        N XTMUI,XTX1,XTX2,LINE
        ; 100622 JLI added code to identify STARTUP and TEARDOWN
        I $T(@("STARTUP^"_XTMUROUN))'="",'$D(@XTVALUE@("STARTUP")) S @XTVALUE@("STARTUP")="STARTUP^"_XTMUROUN
        I $T(@("SHUTDOWN^"_XTMUROUN))'="",'$D(@XTVALUE@("SHUTDOWN")) S @XTVALUE@("SHUTDOWN")="SHUTDOWN^"_XTMUROUN
        F XTMUI=1:1 S LINE=$T(@("XTENT+"_XTMUI_"^"_XTMUROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTX2=$P(LINE,";",4),XTMUNCNT=XTMUNCNT+1,@XTVALUE@(XTMUNCNT)=XTMUROUN_U_XTX1_U_XTX2
        F XTMUI=1:1 S LINE=$T(@("XTROU+"_XTMUI_"^"_XTMUROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTCOMNT=$P(LINE,";",4) I '$D(XTMUROUL(XTX1)) S XTMUROUL(XTX1)="" D LOAD(XTX1,.XTMUNCNT,XTVALUE,XTCOMNT,.XTMUROUL)
        Q
        ;
GUINEXT(XTMURSLT,XTMULOC,XTGUISEP)      ; Entry point for GUI execute next test
        ; XTGUISEP - added 110719 to provide for changing separator for GUI
        ;            return from ^ to another value ~~^~~  so that data returned
        ;            is not affected by ^ values in the data - if not present
        ;            sets value to default ^
        N XTMUETRY,XTMUROUT,XTOLROU,XTVALUE,XTMUERR,XTMUGUI
        N XTMUNIT
        I $G(XTGUISEP)="" S XTGUISEP="^"
        D SETUT
        S XTMUNIT("CNT")=0,XTMUNIT("LOC")=XTMULOC
        S XTVALUE=$NA(^TMP("GUI-MUNIT",$J))
        S XTMUNIT("RSLT")=$NA(^TMP("GUINEXT",$J)) K @XTMUNIT("RSLT")
        S XTMURSLT=XTMUNIT("RSLT")
        S XTMUETRY=$P(XTMULOC,U),XTMUROUT=$P(XTMULOC,U,2),XTOLROU=$G(@XTVALUE@("LASTROU"))
        S XTMUGUI=1
        I XTMUROUT'=XTOLROU D  I XTMUROUT="" S @XTMURSLT@(1)="" K @XTVALUE Q
        . ; 100622 JLI added code to handle STARTUP for GUI app
        . I XTOLROU="",$D(@XTVALUE@("STARTUP")) D
        . . S XTMUNIT("LOC")=@XTVALUE@("STARTUP")
        . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
        . . D @(@XTVALUE@("STARTUP"))
        . . Q
        . I XTOLROU'="" I $T(@("TEARDOWN^"_XTOLROU))'="" D
        . . S XTMUNIT("LOC")="TEARDOWN^"_XTMUROUT
        . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
        . . D @("TEARDOWN^"_XTOLROU)
        . . Q
        . S @XTVALUE@("LASTROU")=XTMUROUT I XTMUROUT'="",$T(@("SETUP^"_XTMUROUT))'="" D
        . . S XTMUNIT("LOC")="SETUP^"_XTMUROUT
        . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
        . . D @("SETUP^"_XTMUROUT)
        . . Q
        . ; 100622 JLI added code to handle SHUTDOWN
        . I XTMUROUT="",$D(@XTVALUE@("SHUTDOWN")) D
        . . S XTMUNIT("LOC")=@XTVALUE@("SHUTDOWN")
        . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
        . . D @(@XTVALUE@("SHUTDOWN"))
        . . Q
        . Q
        S XTMUNIT("LOC")=XTMULOC
        S XTMUNIT("CHK")=0,XTMUNIT("CNT")=1,XTMUERR=0
        D  ; to limit range of error trap so we continue through other tests
        . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
        . D @XTMUNIT("LOC")
        S @XTMUNIT("RSLT")@(1)=XTMUNIT("CHK")_XTGUISEP_(XTMUNIT("CNT")-1-XTMUERR)_XTGUISEP_XTMUERR
        Q

XTMUNIT1
XTMUNIT1        ;JLI/FO-OAK-CONTINUATION OF UNIT TEST ROUTINE ; 18 DEC 2013
        ;;7.3;TOOLKIT;**81**;APR 25 1995;Build 24
    ;
    ; Original by Dr. Joel Ivey
    ; Major contributions by Dr. Sam Habiel
    ;
    ; Changes:
    ; 130726 SMH - Moved test collection logic from XTMUNIT to here (multiple places)
    ; 131218 SMH - dependence on XLFSTR removed
    ; 131218 SMH - CHEKTEST refactored to use $TEXT instead of ^%ZOSF("LOAD")
    ; 131218 SMH - CATCHERR now nulls out $ZS if on GT.M
    ; 
    ; TODO: find this routine and add to repo.
        D EN^XTMUNIT("ZZUTXTMU")
        Q
        ;
CHEKTEST(ROU,XTMUNIT,XTMUETRY)  ; Collect Test list.
        ; XTMROU - input - Name of routine to check for tags with @TEST attribute
        ; XTMUNIT - input/output - passed by reference
        ; XTMUETRY - input/output - passed by reference
        ; 
        ; Test list collected in two ways:
        ; - @TEST on labellines
        ; - Offsets of XTENT
        ;
        ; NB: VEN/SMH - first block moved from XTMUNIT
        S XTMUNIT("ENTN")=0 ; Number of test, sub to XTMUETRY.
        ;
        F XTMUI=1:1 S XTMUNIT("ELIN")=$T(@("XTENT+"_XTMUI_"^"_XTMUROU(XTMUNIT("CURR")))) Q:$P(XTMUNIT("ELIN"),";",3)=""  D
        . S XTMUNIT("ENTN")=XTMUNIT("ENTN")+1,XTMUETRY(XTMUNIT("ENTN"))=$P(XTMUNIT("ELIN"),";",3),XTMUETRY(XTMUNIT("ENTN"),"NAME")=$P(XTMUNIT("ELIN"),";",4)
        ; VEN/SMH - END
        ;
    ; VEN/SMH - block refactored to use $TEXT instead of ^%ZOSF("LOAD")
        N I,LINE
        S I=$L($T(@(U_ROU))) I I<0 Q "-1^Invalid Routine Name"
        N $ETRAP S $ETRAP="D CATCHERR^XTMUNIT1"
    ;
    ; Complexity galore: $TEXT loops through routine
    ; IF tab or space isn't the first character ($C(9,32)) and line contains @TEST
    ; Load that line as a testing entry point
        F I=1:1 S LINE=$T(@("+"_I_U_ROU)) Q:LINE=""  I $C(9,32)'[$E(LINE),$$UP(LINE)["@TEST" D
        . N TAGNAME,CHAR,NPAREN S TAGNAME="",NPAREN=0
        . F  Q:LINE=""  S CHAR=$E(LINE),LINE=$E(LINE,2,999) Q:CHAR=""  Q:" ("[CHAR  S TAGNAME=TAGNAME_CHAR
        . ; should be no paren or arguments
        . I CHAR="(" Q
        . F  Q:LINE=""  S CHAR=$E(LINE) Q:" ;"'[CHAR  S LINE=$E(LINE,2,999)
        . I $$UP($E(LINE,1,5))="@TEST" S LINE=$E(LINE,6,999) D
        . . S XTMUNIT("ENTN")=XTMUNIT("ENTN")+1,XTMUETRY(XTMUNIT("ENTN"))=TAGNAME
        . . F  Q:LINE=""  S CHAR=$E(LINE) Q:CHAR?1AN  S LINE=$E(LINE,2,999)
        . . S XTMUETRY(XTMUNIT("ENTN"),"NAME")=LINE
        QUIT
        ;
    ; VEN/SMH - Is this catch needed anymore?
CATCHERR        ; catch error on trying to load file if it doesn't exist ; JLI 120806
        S $ZE="",$EC=""
    I +$SY=47 S $ZS="" ; VEN/SMH fur GT.M.
    QUIT
        ;
        ; VEN/SMH 26JUL2013 - Moved GETTREE here.
GETTREE(XTMUROU,XTMULIST)       ;
        ; first get any other routines this one references for running subsequently
        ; then any that they refer to as well
        ; this builds a tree of all routines referred to by any routine including each only once
        N XTMUK,XTMUI,XTMUJ,XTMURNAM,XTMURLIN
        F XTMUK=1:1 Q:'$D(XTMUROU(XTMUK))  D
        . F XTMUI=1:1 S XTMURLIN=$T(@("XTROU+"_XTMUI_"^"_XTMUROU(XTMUK))) S XTMURNAM=$P(XTMURLIN,";",3) Q:XTMURNAM=""  D
        . . F XTMUJ=1:1:XTMULIST I XTMUROU(XTMUJ)=XTMURNAM S XTMURNAM="" Q
        . . I XTMURNAM'="",$T(@("+1^"_XTMURNAM))="" W:'$D(XWBOS) "Referenced routine ",XTMURNAM," not found.",! Q
        . . S:XTMURNAM'="" XTMULIST=XTMULIST+1,XTMUROU(XTMULIST)=XTMURNAM
        QUIT
    ;
    ; VEN/SMH 17DEC2013 - Remove dependence on VISTA - Uppercase here instead of XLFSTR.
UP(X)  Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")



